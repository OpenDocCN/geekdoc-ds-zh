- en: 5.2Â Processing ListsğŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/processing-lists.html](https://dcic-world.org/2025-08-27/processing-lists.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [5.2.1Â Making Lists and Taking Them Apart](#%28part._.Making_.Lists_and_.Taking_.Them_.Apart%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.2Â Some Example Exercises](#%28part._my-len%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.3Â Structural Problems with Scalar Answers](#%28part._.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.3.1Â `my-len`: Examples](#%28part._len-eg%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.3.2Â `my-sum`: Examples](#%28part._sum-eg%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.3.3Â From Examples to Code](#%28part._.From_.Examples_to_.Code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.4Â Structural Problems that Transform Lists](#%28part._.Structural_.Problems_that_.Transform_.Lists%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.4.1Â `my-doubles`: Examples and Code](#%28part._doubles-eg-code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.4.2Â `my-str-len`: Examples and Code](#%28part._str-len-eg-code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.5Â Structural Problems that Select from Lists](#%28part._.Structural_.Problems_that_.Select_from_.Lists%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.5.1Â `my-pos-nums`: Examples and Code](#%28part._pos-nums-eg-code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.5.2Â `my-alternating`: Examples and Code](#%28part._alternating-eg-code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.6Â Structural Problems Over Relaxed Domains](#%28part._struct-prob-sub-dom%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.6.1Â `my-max`: Examples](#%28part._my-max%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.6.2Â `my-max`: From Examples to Code](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.7Â More Structural Problems with Scalar Answers](#%28part._.More_.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.7.1Â `my-avg`: Examples](#%28part._avg-eg%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.8Â Structural Problems with Accumulators](#%28part._accumulators%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.8.1Â `my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.8.2Â `my-running-sum`: Examples and Code](#%28part._running-sum-eg-code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.8.3Â `my-alternating`: Examples and Code](#%28part._alternating-accumulator%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.9Â Dealing with Multiple Answers](#%28part._.Dealing_with_.Multiple_.Answers%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.9.1Â `uniq`: Problem Setup](#%28part._uniq%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.9.2Â `uniq`: Examples](#%28part._uniq-eg%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.9.3Â `uniq`: Code](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.9.4Â `uniq`: Reducing Computation](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.9.5Â `uniq`: Example and Code Variations](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [5.2.9.6Â `uniq`: Why Produce a List?](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [5.2.10Â Monomorphic Lists and Polymorphic Types](#%28part._polymorphic-data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'We have already seen [[From Tables to Lists](tables-to-lists.html)] several
    examples of list-processing functions. They have been especially useful for advanced
    processing of tables. However, lists arise frequently in programs, and they do
    so naturally because so many things in our livesâ€”<wbr>from shopping lists to to-do
    lists to checklistsâ€”<wbr>are naturally lists. Thinking about the functions that
    we might want when processing lists, we can observe that there are some interesting
    categories regarding the types of the data in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'some list functions are generic and operate on any kind of list: e.g., the
    length of a list is the same irrespective of what kind of values it contains;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'some are specific at least to the type of data: e.g., the sum assumes that
    all the values are numbers (though they may be ages or prices or other information
    represented by numbers); and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'some are somewhere in-between: e.g., a maximum function applies to any list
    of comparable values, such as numbers or strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This seems like a great variety, and we might worry about how we can handle
    this many different kinds of functions. Fortunately, and perhaps surprisingly,
    there is one standard way in which we can think about writing all these functions!
    Understanding and internalizing this process is the goal of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1Â Making Lists and Taking Them Apart[ğŸ”—](#(part._.Making_.Lists_and_.Taking_.Them_.Apart)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far weâ€™ve seen one way to make a list: by writing `[list: â€¦]`. While useful,
    writing lists this way actually hides their true nature. Every list actually has
    two parts: a first element and the rest of the list. The rest of the list is itself
    a list, so it too has two partsâ€¦and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the list `[list: 1, 2, 3]`. Its first element is `1`, and the rest
    of it is `[list: 2, 3]`. For this second list, the first element is `2` and the
    rest is `[list: 3]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take apart this third list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For the third list, the first element is `3` and the rest is `[list: ]`, i.e.,
    the empty list. In Pyret, we have another way of writing the empty list: `empty`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are an instance of structured data: data with component parts and a well-defined
    format for the shape of the parts. Lists are formatted by the first element and
    the rest of the elements. Tables are somewhat structured: they are formatted by
    rows and columns, but the column names arenâ€™t consistent across all tables. Structured
    data is valuable in programming because a predictable format (the structure) lets
    us write programs based on that structure. What do we mean by that?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming languages can (and do!) provide built-in operators for taking apart
    structured data. These operators are called accessors. Accessors are defined on
    the structure of the datatype alone, independent of the contents of the data.
    In the case of lists, there are two accessors: `first` and `rest`. We use an accessor
    by writing an expression, followed by a dot (`.`), followed by the accessorâ€™s
    name. As we saw with tables, the dot means "dig into". Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the accessors for tables?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Accessors give a way to take data apart based on their structure (there is
    another way that we will see shortly). Is there a way to also build data based
    on its structure? So far, we have been building lists using the `[list: ...]`
    form, but that doesnâ€™t emphasize the structural constraint that the `rest` is
    itself a list. A structured operator for building lists would clearly show both
    a `first` element and a `rest` that is itself a list. Operators for building structured
    data are called constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for lists is called `link`. It takes two arguments: a `first`
    element, and the list to build on (the `rest` part). Hereâ€™s an example of using
    `link` to create a three-element list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `link` form creates the same underlying list datum as our previous `[list:
    ...]` operation, as confirmed by the following check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look at these two forms of writing lists: what differences do you notice?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `link` form to write a four-element list of fruits containing `"lychee"`,
    `"dates"`, `"mango"`, and `"durian"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'After doing this exercise, you might wonder why anyone would use the `link`
    form: itâ€™s more verbose, and makes the individual elements harder to discern.
    This form is not very convenient to humans. But it will prove very valuable to
    programs!'
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the `link` form highlights that we really have two different
    structures of lists. Some lists are empty. All other lists are non-empty lists,
    meaning they have at least one `link`. There may be more interesting structure
    to some lists (as we will see later), but all lists have this much in common.
    Specifically, a list is either
  prefs: []
  type: TYPE_NORMAL
- en: 'empty (written `empty` or `[list: ]`), or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'non-empty (written `link(â€¦, â€¦)` or `[list: ]` with at least one value inside
    the brackets), where the rest is also a list (and hence may in turn be empty or
    non-empty, â€¦).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means we actually have two structural features of lists, both of which
    are important when writing programs over lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Lists can be empty or non-empty
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Non-empty lists have a first element and a rest of the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Letâ€™s leverage these two structural features to write some programs to process
    lists!
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2Â Some Example Exercises[ğŸ”—](#(part._my-len) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To illustrate our thinking, letâ€™s work through a few concrete examples of list-processing
    functions. All of these will consume lists; some will even produce them. Some
    will transform their inputs (like `map`), some will select from their inputs (like
    `filter`), and some will aggregate their inputs. Since some of these functions
    already exist in Pyret, weâ€™ll name them with the prefix `my-` to avoid errors.Be
    sure to use the `my-` name consistently, including inside the body of the function.
    As we will see, there is a standard strategy that we can use to approach writing
    all of these functions: having you learn this strategy is the goal of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3Â Structural Problems with Scalar Answers[ğŸ”—](#(part._.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Letâ€™s write out examples for a few of the functions described above. Weâ€™ll
    approach writing examples in a very specific, stylized way. First of all, we should
    always construct at least two examples: one with `empty` and the other with at
    least one `link`, so that weâ€™ve covered the two very broad kinds of lists. Then,
    we should have more examples specific to the kind of list stated in the problem.
    Finally, we should have even more examples to illustrate how we think about solving
    the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.3.1Â `my-len`: Examples[ğŸ”—](#(part._len-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a list. We confront
    this right away when trying to write an example. What is the length of the list
    `empty`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two common examples are `0` and `1`. The latter, `1`, certainly looks reasonable.
    However, if you write the list as `[list: ]`, now it doesnâ€™t look so right: this
    is clearly (as the name `empty` also suggests) an empty list, and an empty list
    has zero elements in it. Therefore, itâ€™s conventional to declare that'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'How about a list like `[list: 7]`? Well, itâ€™s clearly got one element (`7`)
    in it, so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for a list like `[list: 7, 8, 9]`, we would say'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now letâ€™s look at that last example in a different light. Consider the argument
    `[list: 7, 8, 9]`. Its first element is `7` and the rest of it is `[list: 8, 9]`.
    Well, `7` is a number, not a list; but `[list: 8, 9]` certainly is a list, so
    we can ask for its length. What is `my-len([list: 8, 9])`? It has two elements,
    so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of that list is `8` while its rest is `[list: 9]`. What is
    its length? Note that we asked a very similar question before, for the length
    of the list `[list: 7]`. But `[list: 7]` is not a sub-list of `[list: 7, 8, 9]`,
    which we started with, whereas `[list: 9]` is. And using the same reasoning as
    before, we can say'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The rest of this last list is, of course, the empty list, whose length we have
    already decided is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together these examples, and writing out `empty` in its other form,
    hereâ€™s what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another way we can write this (paying attention to the right side) is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Where did the `2`, `1`, and `0` on the right sides of each `+` operation come
    from? Those are the lengths of the `rest` component of the input list. In the
    previous example block, we wrote those lengths as explicit examples. Letâ€™s substitute
    the numbers `2`, `1`, and `0` with the `my-len` expressions that produce them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From this, maybe you can start to see a pattern. For an empty list, the length
    is `0`. For a non-empty list, itâ€™s the sum of `1` (the first elementâ€™s â€œcontributionâ€
    to the listâ€™s length) to the length of the rest of the list. In other words, we
    can use the result of computing `my-len` on the rest of the list to compute the
    answer for the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each of our examples in this section has written a different check on the expression
    `my-len([list: 7, 8, 9])`. Here are those examples presented together, along with
    one last one that explicitly uses the `rest` operation:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that you agree with each of these assertions. Also check whether you understand
    how the right-hand side of each `is` expression derives from the right-hand-side
    just above it. The goal of this exercise is to make sure that you believe that
    the last check (which we will turn into code) is equivalent to the first (which
    we wrote down when understanding the problem).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.3.2Â `my-sum`: Examples[ğŸ”—](#(part._sum-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s repeat this process of developing examples on a second function, this
    time one that computes the sum of the elements in a list of numbers. What is the
    sum of the list `[list: 7, 8, 9]`? Just adding up the numbers by hand, the result
    should be `24`. Letâ€™s see how that works out through the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting aside the empty list for a moment, here are examples that show the
    sum computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: which (by substitution) is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we can see that the sum of the empty list must be `0`:Zero is called
    the additive identity: a fancy way of saying, adding zero to any number N gives
    you N. Therefore, it makes sense that it would be the length of the empty list,
    because the empty list has no items to contribute to a sum. Can you figure out
    what the multiplicative identity is?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Observe, again, how we can use the result of computing `my-sum` of the rest
    of the list to compute its result for the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3.3Â From Examples to Code[ğŸ”—](#(part._.From_.Examples_to_.Code) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having developed these examples, we now want to use them to develop a program
    that can compute the length or the sum of any list, not just the specific ones
    we used in these examples. As we have done up in earlier chapters, we will leverage
    patterns in the examples to figure out how to define the general-purpose function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one last version of the examples for `my-len`, this time making the
    `rest` explicit on the right-hand sides of `is`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did when developing functions over images, letâ€™s try to identify the
    common parts of these examples. We start by noticing that most of the examples
    have a lot in common, except for the `[list: ]` (`empty`) case. So letâ€™s separate
    this into two sets of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this separation (which follows one of the structural features of lists
    that we mentioned earlier), a clearer pattern emerges: for a non-empty list (called
    `someList`), we compute its length via the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In general, then, our `my-len` program needs to determine whether its input
    list is empty or non-empty, using this expression with `.rest` in the non-empty
    case. How do we indicate different code based on the structure of the list?
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyret has a construct called `cases` which is used to distinguish different
    forms within a structured datatype. When working with lists, the general shape
    of a `cases` expression is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'where most parts are fixed, but a few youâ€™re free to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`e` is an expression whose value needs to be a list; it could be a variable
    bound to a list, or some complex expression that evaluates to a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` and `r` are names given to the first and rest of the list. You can choose
    any names you like, though in Pyret, itâ€™s conventional to use `f` and `r`.Occasionally
    using different names can help students recall that they can choose how to label
    the `first` and `rest` components. This can be particularly useful for `first`,
    which has a problem-specific meaning (such as `price` in a list of prices, and
    so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right-hand side of every `=>` is an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Hereâ€™s how `cases` works in this instance. Pyret first evaluates `e`. It then
    checks that the resulting value truly is a list; otherwise it halts with an error.
    If it is a list, Pyret examines what kind of list it is. If itâ€™s an empty list,
    it runs the expression after the `=>` in the `empty` clause. Otherwise, the list
    is not empty, which means it has a first and rest; Pyret binds `f` and `r` to
    the two parts, respectively, and then evaluates the expression after the `=>`
    in the `link` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try using a non-listâ€”<wbr>e.g., a numberâ€”<wbr>in the `e` position and see what
    happens!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now letâ€™s use `cases` to define `my-len`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows from our examples: when the list is empty `my-len` produces `0`;
    when it is not empty, we add one to the length of the rest of the list (here,
    `r`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while our most recent collection of `my-len` examples explicitly said
    `.rest`, when using `cases` we instead use just the name `r`, which Pyret has
    already defined (under the hood) to be `l.rest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, letâ€™s define `my-sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how similar they are in code, and how readily the structure of the data
    suggest a structure for the program. This is a pattern you will get very used
    to soon!
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Developing Functions Over Lists'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage the structure of lists and the power of concrete examples to develop
    list-processing functions.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pick a concrete list with (at least) three elements. Write a sequence of examples
    for each of the entire list and each suffix of the list (including the empty list).
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Rewrite each example to express its expected answer in terms of the `first`
    and `rest` data of its input list. You donâ€™t have to use the `first` and `rest`
    operators in the new answers, but you should see the `first` and `rest` values
    represented explicitly in the answer.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look for a pattern across the answers in the examples. Use these to develop
    the code: write a `cases` expression, filling in the right side of each `=>` based
    on your examples.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This strategy applies to structured data in general, leveraging components of
    each datum rather than specifically `first` and `rest` as presented so far.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.2.4Â Structural Problems that Transform Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Transform_.Lists)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have a systematic way to develop functions that take lists as input,
    letâ€™s apply that same strategy to functions that produce a list as the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.4.1Â `my-doubles`: Examples and Code[ğŸ”—](#(part._doubles-eg-code) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As always, weâ€™ll begin with some examples. Given a list of numbers, we want
    a list that doubles each number (in the order of the original list). Hereâ€™s a
    reasonable example with three numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, letâ€™s write out the answers for each suffix of our example list
    as well, including for the `empty` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rewrite the answer expressions to include the concrete `first` and
    `rest` data for each example. Letâ€™s start with just the `first` data, and just
    on the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, letâ€™s include the `rest` data (`[list: 5, 2]`) in the first example.
    The current answer in the first example is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'and that `[list: 10, 4]` is the result of using the function on `[list: 5,
    2]`. We might therefore be tempted to replace the right side of the first example
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What value would this expression produce? You might want to try this example
    that doesnâ€™t use `my-doubles` directly:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Oops! We want a single (flat) list, not a list-within-a-list. This feels like
    it is on the right track in terms of reworking the answer to use the `first` and
    `rest` values, but weâ€™re clearly not quite there yet.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value does the following expression produce?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 'Notice the difference between the two expressions in these last two exercises:
    the latter used `link` to put the value involving `first` into the conversion
    of the `rest`, while the former tried to do this with `list:`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many elements are in the lists that result from each of the following expressions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summarize the difference between how `link` and `list:` combine an element and
    a list. Try additional examples at the interactions prompt if needed to explore
    these ideas.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The takeaway here is that we use `link` to insert an element into an existing
    list, whereas we use `list:` to make a new list that contains the old list as
    an element. Going back to our examples, then, we include `rest` in the first example
    by writing it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: which we then convert to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this idea across the examples, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have examples that explicitly use the `first` and `rest` elements,
    we can produce to write the `my-doubles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '5.2.4.2Â `my-str-len`: Examples and Code[ğŸ”—](#(part._str-len-eg-code) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In `my-doubles`, the input and output lists have the same type of element.
    Functions can also produce lists whose contents have a different type from the
    input list. Letâ€™s work through an example. Given a list of strings, we want the
    lengths of each string (in the same order as in the input list). Thus, hereâ€™s
    a reasonable example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have before, we should consider the answers for each sub-problem of the
    above example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'which tells us that the response for the empty list should be `empty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to rework the answers in the examples to make the `first`
    and `rest` parts explicit. Hopefully by now you are starting to detect a pattern:
    The result on the rest of the list appears explicitly as another example. Therefore,
    weâ€™ll start by getting the `rest` value of each example input into the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains now is to figure out how to work the `first` values into the
    outputs. In the context of this problem, this means we need to convert `"hi"`
    into `2`, `"there"` into `5`, and so on. From the problem statement, we know that
    `2` and `5` are meant to be the lengths (character counts) of the corresponding
    strings. The operation that determines the length of a string is called `string-length`.
    Thus, our examples appear as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we write a function that captures the pattern developed across our
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 5.2.5Â Structural Problems that Select from Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Select_from_.Lists)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the previous section, we saw functions that transform list elements (by
    doubling numbers or counting characters). The type of the output list may or may
    not be the same as the type of the input list. Other functions that produce lists
    instead select elements: every element in the output list was in the input list,
    but some input-list elements might not appear in the output list. This section
    adapts our method of deriving functions from examples to accommodate selection
    of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.5.1Â `my-pos-nums`: Examples and Code[ğŸ”—](#(part._pos-nums-eg-code) "Link
    to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As our first example, we will select the positive numbers from a list that contains
    both positive and non-positive numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct the sequence of examples that we obtain from the input `[list: 1,
    -2, 3, -4]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write this in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: or, even more explicitly,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike in the example sequences for functions that transform lists, here we
    see that the answers have different shapes: some involve a `link`, while others
    simply process the `rest` of the list. Whenever we need different shapes of outputs
    across a set of examples, we will need an `if` expression in our code to distinguish
    the conditions that yield each shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What determines which shape of output we get? Letâ€™s rearrange the examples
    (other than the empty-list input) by output shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Re-organized, we can see that the examples that use `link` have a positive
    number in the `first` position, while the ones that donâ€™t simply process the `rest`
    of the list. That indicates that our `if` expression needs to ask whether the
    `first` element in the list is positive. This yields the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is our set of examples comprehensive?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not really. There are many examples we havenâ€™t considered, such as lists that
    end with positive numbers and lists with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through these examples and see how they affect the program!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.5.2Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-eg-code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now letâ€™s consider a problem that selects elements not by value, but by position.
    We want to write a function that selects alternating elements from a list. Once
    again, weâ€™re going to work from examples.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-alternating` starting from the list `[list: 1,
    2, 3, 4, 5, 6]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hereâ€™s how they work out:'
  prefs: []
  type: TYPE_NORMAL
- en: <alternating-egs-1> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait, whatâ€™s that? The two answers above are each correct, but the second answer
    does not help us in any way construct the first answer. That means the way weâ€™ve
    solved these problems until now is not enough for this new kind of problem. Itâ€™s
    still useful, though: notice that thereâ€™s a connection between the first example
    and the third, as well as between the second example and the fourth. This observation
    is consistent with our goal of selecting alternating elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What would something like this look like in code? Before we try to write the
    function, letâ€™s rewrite the first example in terms of the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the rewritten version, we are dropping two elements from the list
    before using `my-alternating` again, not just one. We will have to figure out
    how to handle that in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s start with our usual function pattern with a `cases` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we cannot simply call `my-alternating` on `r`, because `r` excludes
    only one item from the list, not two as this problem requires. We have to break
    down `r` as well, in order to get to the `rest` of the `rest` of the original
    list. To do this, we use another `cases` expression, nested within the first `cases`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is consistent with the example that we just worked out. But note
    that we still have a bit of unfinished work to do: we need to decide what to do
    in the `empty` case of the inner `cases` expression (marked by `???` in the code).'
  prefs: []
  type: TYPE_NORMAL
- en: A common temptation at this point is to replace the `???` with `[list:]`. After
    all, havenâ€™t we always returned `[list:]` in the `empty` cases?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Replace `???` with `[list:]` and test the program on our original examples:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you observe?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Oops! Weâ€™ve written a program that appears to work on lists with an even number
    of elements, but not on lists with an odd number of elements. How did that happen?
    The only part of this code that we guessed at was how to fill in the `empty` case
    of the inner `cases`, so the issue must be there. Rather than focus on the code,
    however, focus on the examples. We need a simple example that would land on that
    part of the code. We get to that spot when the list `l` is not empty, but `r`
    (the rest of `l`) is empty. In other words, we need an example with only one element.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finish the following example:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Given a list with one element, that element should be included in a list of
    alternating elements. Thus, we should finish this example as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this example to update the result of `my-alternating` when `r` is `empty`
    in our code.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Leveraging this new example, the final version of `my-alternating` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatâ€™s the takeaway from this problem? There are two:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Donâ€™t skip the small examples: the result of a list-processing function on
    the `empty` case wonâ€™t always be `empty`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a problem asks you to work with multiple elements from the front of a list,
    you can nest `cases` expressions to access later elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These takeaways will matter again in future examples: keep an eye out for them!'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.6Â Structural Problems Over Relaxed Domains[ğŸ”—](#(part._struct-prob-sub-dom)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '5.2.6.1Â `my-max`: Examples[ğŸ”—](#(part._my-max) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now letâ€™s find the maximum value of a list. Letâ€™s assume for simplicity that
    weâ€™re dealing with just lists of numbers. What kinds of lists should we construct?
    Clearly, we should have empty and non-empty listsâ€¦but what else? Is a list like
    `[list: 1, 2, 3]` a good example? Well, thereâ€™s nothing wrong with it, but we
    should also consider lists where the maximum is at the beginning rather than at
    the end; the maximum might be in the middle; the maximum might be repeated; the
    maximum might be negative; and so on. While not comprehensive, here is a small
    but interesting set of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: What about `my-max(empty)`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Could we define `my-max(empty)` to be `0`? Returning `0` for the empty list
    has worked well twice already!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Weâ€™ll return to this in a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, itâ€™s useful to know that thereâ€™s a function called `num-max`
    already defined in Pyret, that compares two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose `num-max` were not already built in. Can you define it? You will find
    what you learned about [Booleans](Conditionals_and_Booleans.html#%28part._booleans%29)
    handy. Remember to write some tests!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now we can look at `my-max` at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be sure.
    And we still donâ€™t know what to do with `empty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s try the second example input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually telling us something useful as well, but maybe we canâ€™t see
    it yet. Letâ€™s take on something more ambitious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how the maximum of the rest of the list gives us a candidate answer,
    but comparing it to the first element gives us a definitive one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The last one is a little awkward: weâ€™d like to write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: but we donâ€™t really know what the maximum (or minimum, or any other element)
    of the empty list is, but we can only provide numbers to `num-max`. Therefore,
    leaving out that dodgy case, weâ€™re left with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Our examples have again helped: theyâ€™ve revealed how we can use the answer
    for each rest of the list to compute the answer for the whole list, which in turn
    is the rest of some other list, and so on. If you go back and look at the other
    example lists we wrote above, youâ€™ll see the pattern holds there too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, itâ€™s time we now confront the `empty` case. The real problem is that
    we donâ€™t have a maximum for the empty list: for any number we might provide, there
    is always a number bigger than it (assuming our computer is large enough) that
    could have been the answer instead. In short, itâ€™s nonsensical to ask for the
    maximum (or minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
    on non-empty lists! That is, when asked for the maximum of an empty list, we should
    signal an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: (which is how, in Pyret, we say that it will generate an error; we donâ€™t care
    about the details of the error, hence the empty string).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.6.2Â `my-max`: From Examples to Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once again, we can codify the examples above, i.e., turn them into a uniform
    program that works for all instances. However, we now have a twist. If we blindly
    followed the pattern weâ€™ve used earlier, we would end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s wrong with this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Consider the list `[list: 2]`. This turns into'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: which of course raises an error. Therefore, this function never works for any
    list that has one or more elements!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thatâ€™s because we need to make sure we arenâ€™t trying to compute the maximum
    of the empty list. Going back to our examples, we see that what we need to do,
    before calling `my-max`, is check whether the rest of the list is empty. If it
    is, we do not want to call `my-max` at all. That is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Weâ€™ll return to what to do when the rest is not empty in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the rest of the list `l` is empty, our examples above tell us that the maximum
    is the first element in the list. Therefore, we can fill this in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in particular the absence of a call to `my-max`. If the list is not empty,
    however, our examples above tell us that `my-max` will give us the maximum of
    the rest of the list, and we just need to compare this answer with the first element
    (`f`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, this definition does the job!
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.7Â More Structural Problems with Scalar Answers[ğŸ”—](#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '5.2.7.1Â `my-avg`: Examples[ğŸ”—](#(part._avg-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start with
    the example list `[list: 1, 2, 3, 4]` and work out more examples from it. The
    average of numbers in this list is clearly `(1 + 2 + 3 + 4)/4`, or `10/4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the listâ€™s structure, we see that the rest of the list is `[list:
    2, 3, 4]`, and the rest of that is `[list: 3, 4]`, and so on. The resulting averages
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is, itâ€™s simply not clear how we get from the answer for the sub-list
    to the answer for the whole list. That is, given the following two bits of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The average of the remainder of the list is `9/3`, i.e., `3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first number in the list is `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we determine that the average of the whole list must be `10/4`? If itâ€™s
    not clear to you, donâ€™t worry: with just those two pieces of information, itâ€™s
    impossible!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first value in
    a list is `1`, and the average of the rest of the list is `2`. Here are two very
    different lists that fit this description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The average of the entire first list is `3/2`, while the average of the entire
    second list is `5/3`, and the two are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: That is, to compute the average of a whole list, itâ€™s not even useful to know
    the average of the rest of the list. Rather, we need to know the sum and the length
    of the rest of the list. With these two, we can add the first to the sum, and
    `1` to the length, and compute the new average.
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, we could try to make a `average` function that returns all this
    information. Instead, it will be a lot simpler to simply decompose the task into
    two smaller tasks. After all, we have already seen how to compute the length and
    how to compute the sum. The average, therefore, can just use these existing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be the average of the empty list? Does the above code produce what
    you would expect?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Just as we argued earlier about the maximum [[Structural Problems Over Relaxed
    Domains](#%28part._struct-prob-sub-dom%29)], the average of the empty list isnâ€™t
    a well-defined concept. Therefore, it would be appropriate to signal an error.
    The implementation above does this, but poorly: it reports an error on division.
    A better programming practice would be to catch this situation and report the
    error right away, rather than hoping some other function will report the error.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alter `my-avg` above to signal an error when given the empty list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Therefore, we see that the process weâ€™ve usedâ€”<wbr>of inferring code from examplesâ€”<wbr>wonâ€™t
    always suffice, and weâ€™ll need more sophisticated techniques to solve some problems.
    However, notice that working from examples helps us quickly identify situations
    where this approach does and doesnâ€™t work. Furthermore, if you look more closely
    youâ€™ll notice that the examples above do hint at how to solve the problem: in
    our very first examples, we wrote answers like `10/4`, `9/3`, and `7/2`, which
    correspond to the sum of the numbers divided by the length. Thus, writing the
    answers in this form (as opposed, for instance, to writing the second of those
    as `3`) already reveals a structure for a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.8Â Structural Problems with Accumulators[ğŸ”—](#(part._accumulators) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '5.2.8.1Â `my-running-sum`: First Attempt[ğŸ”—](#(part._running-sum-1st-attempt)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One more time, weâ€™ll begin with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-running-sum` starting from the list `[list: 1,
    2, 3, 4, 5]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hereâ€™s what our first few examples look like:'
  prefs: []
  type: TYPE_NORMAL
- en: <running-sum-egs-1> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Again, there doesnâ€™t appear to be any clear connection between the result on
    the rest of the list and the result on the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: '(That isnâ€™t strictly true: we can still line up the answers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: and observe that weâ€™re computing the answer for the rest of the list, then adding
    the first element to each element in the answer, and `link`ing the first element
    to the front. In principle, we can compute this solution directly, but for now
    that may be more work than finding a simpler way to answer it.)
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.8.2Â `my-running-sum`: Examples and Code[ğŸ”—](#(part._running-sum-eg-code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall how we began in [`my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29).
    Our examples [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] showed the
    following problem. When we process the rest of the list, we have forgotten everything
    about what preceded it. That is, when processing the list starting at `2` we forget
    that weâ€™ve seen a `1` earlier; when starting from `3`, we forget that weâ€™ve seen
    both `1` and `2` earlier; and so on. In other words, we keep forgetting the past.
    We need some way of avoiding that.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest thing we can do is simply change our function to carry along this
    â€œmemoryâ€, or what weâ€™ll call an accumulator. That is, imagine we were defining
    a new function, called `my-rs`. It will consume a list of numbers and produce
    a list of numbers, but in addition it will also take the sum of numbers preceding
    the current list.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should the initial sum be?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Initially there is no â€œpreceding listâ€, so we will use the additive identity:
    `0`. The type of `my-rs` is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s now re-work our examples from [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)
    as examples of `my-rs` instead. The examples use the `+` operator to append two
    lists into one (the elements of the first list followed by the elements of the
    second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, `my-rs` translates into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'All thatâ€™s then left is to call it from `my-running-sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Observe that we do not change `my-running-sum` itself to take extra arguments.
    The correctness of our code depends on the initial value of `acc` being 0\. If
    we added a parameter for `acc`, any code that calls `my-running-sum` could supply
    an unexpected value, which would distort the result. In addition, since the value
    is fixed, adding the parameter would amount to shifting additional (and needless)
    work onto others who use our code.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.8.3Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-accumulator)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall our examples in [`my-alternating`: Examples and Code](#%28part._alternating-eg-code%29).
    There, we noticed that the code built on every-other example. We might have chosen
    our examples differently, so that from one example to the next we skipped two
    elements rather than one. Here we will see another way to think about the same
    problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the examples weâ€™ve already seen [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)].
    We wrote `my-alternating` to traverse the list essentially two elements at a time.
    Another option is to traverse it just one element at a time, but keeping track
    of whether weâ€™re at an odd or even elementâ€”<wbr>i.e., add â€œmemoryâ€ to our program.
    Since we just need to track that one piece of information, we can use a `Boolean`
    to do it. Letâ€™s define a new function for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The extra argument accumulates whether weâ€™re at an element to keep or one to
    discard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the existing template for list functions. When we have an element,
    we have to consult the accumulator whether to keep it or not. If its value is
    `true` we `link` it to the answer; otherwise we ignore it. As we process the rest
    of the list, however, we have to remember to update the accumulator: if we kept
    an element we donâ€™t wish to keep the next one, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to determine the initial value of the accumulator. In this
    case, since we want to keep alternating elements starting with the first one,
    its initial value should be `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `my-max` using an accumulator. What does the accumulator represent? Do
    you encounter any difficulty?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.2.9Â Dealing with Multiple Answers[ğŸ”—](#(part._.Dealing_with_.Multiple_.Answers)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our discussion above has assumed there is only one answer for a given input.
    This is often true, but it also depends on how the problem is worded and how we
    choose to generate examples. We will study this in some detail now.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.1Â `uniq`: Problem Setup[ğŸ”—](#(part._uniq) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider the task of writing `uniq`:uniq is the name of a Unix utility with
    similar behavior; hence the spelling of the name. given a list of values, it produces
    a collection of the same elements while avoiding any duplicates (hence `uniq`,
    short for â€œuniqueâ€).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input: `[list: 1, 2, 1, 3, 1, 2, 4, 1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the sequence of examples this input generates? Itâ€™s really important
    you stop and try to do this by hand. As we will see there are multiple solutions,
    and itâ€™s useful for you to consider what you generate. Even if you canâ€™t generate
    a sequence, trying to do so will better prepare you for what you read next.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: How did you obtain your example? If you just â€œthought about it for a moment
    and wrote something downâ€, you may or may not have gotten something you can turn
    into a program. Programs can only proceed systematically; they canâ€™t â€œthinkâ€.
    So, hopefully you took a well-defined path to computing the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.2Â `uniq`: Examples[ğŸ”—](#(part._uniq-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It turns out there are several possible answers, because we have (intentionally)
    left the problem unspecified. Suppose there are two instances of a value in the
    list; which one do we keep, the first or the second? On the one hand, since the
    two instances must be equivalent it doesnâ€™t matter, but it does for writing concrete
    examples and deriving a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you might have generated this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: However, you might have also generated sequences that began with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: and so on. Letâ€™s work with the examples weâ€™ve worked out above.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.3Â `uniq`: Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'What is the systematic approach that gets us to this answer? When given a non-empty
    list, we split it into its first element and the rest of the list. Suppose we
    have the answer to `uniq` applied to the rest of the list. Now we can ask: is
    the first element in the rest of the list? If it is, then we can ignore it, since
    it is certain to be in the `uniq` of the rest of the list. If, however, it is
    not in the rest of the list, itâ€™s critical that we `link` it to the answer.'
  prefs: []
  type: TYPE_NORMAL
- en: This translates into the following program. For the empty list, we return the
    empty list. If the list is non-empty, we check whether the first is in the rest
    of the list. If it is not, we include it; otherwise we can ignore it for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: which weâ€™ve called `uniq-rec` instead of `uniq` to differentiate it from other
    versions of `uniq`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that weâ€™re using `.member` to check whether an element is a member of the
    list. Write a function `member` that consumes an element and a list, and tells
    us whether the element is a member of the list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Uniqueness checking has many practical applications. For example, one might
    have a list of names of people who have registered to vote in an election. To
    keep the voting fair, with only one vote allowed per person, we should remove
    duplicate names from the list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a set of examples for a function `rem-duplicate-voters` that takes a
    list of voter names and returns a list in which duplicate registrations have been
    removed. In developing your examples, consider real-world scenarios that you can
    imagine arising when identifying duplicate names. Can you identify cases in which
    two names might appear to be the same person, but not be? Cases in which two names
    might appear different but be referring to the same person?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What might you need to change about our current `uniq-rec` function to handle
    a situation like removing duplicate voters?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Responsible Computing: Context Matters When Comparing Values'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The data de-duplication context in the above exercise reminds us that different
    contexts may call for different notions of when two data values are the same.
    Sometimes, we want exact matching to determine that two strings are equal. Sometimes,
    we need methods that normalize data, either in simple ways like capitalization
    or subtler ways based on middle initials. Sometimes, we need more information
    (like street addresses in addition to names) in order to determine whether two
    items in a list should be considered â€œthe sameâ€.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is easy to write programs that encode assumptions about our data that might
    not apply in practice. This is again a situation that can be helped by thinking
    about the concrete examples on which your code needs to work in context.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.9.4Â `uniq`: Reducing Computation[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Notice that this function has a repeated expression. Instead of writing it
    twice, we could call it just once and use the result in both places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You might think, because we replaced two function calls with one, that weâ€™ve
    reduced the amount of computation the program does. It does not! The two function
    calls are both in the two branches of the same conditional; therefore, for any
    given list element, only one or the other call to `uniq` happens. In fact, in
    both cases, there was one call to `uniq` before, and there is one now. So we have
    reduced the number of calls in the source program, but not the number that take
    place when the program runs. In that sense, the name of this section was intentionally
    misleading!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one useful reduction we can perform, which is enabled by
    the structure of `uniq-rec2`. We currently check whether `f` is a member of `r`,
    which is the list of all the remaining elements. In our example, this means that
    in the very second turn, we check whether `2` is a member of the list `[list:
    1, 3, 1, 2, 4, 1]`. This is a list of six elements, including three copies of
    `1`. We compare `2` against two copies of `1`. However, we gain nothing from the
    second comparison. Put differently, we can think of `uniq(r)` as a â€œsummaryâ€ of
    the rest of the list that is exactly as good as `r` itself for checking membership,
    with the advantage that it might be significantly shorter. This, of course, is
    exactly what `ur` represents. Therefore, we can encode this intuition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note that all that changed is that we check for membership in `ur` rather than
    in `r`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later [[Predicting Growth](predicting-growth.html)] we will study how to formally
    study how long a program takes to run. By the measure introduced in that section,
    does the change we just made make any difference? Be careful with your answer:
    it depends on how we count â€œthe lengthâ€ of the list.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that if the list never contained duplicates in the first place, then
    it wouldnâ€™t matter which list we check membership inâ€”<wbr>but if we knew the list
    didnâ€™t contain duplicates, we wouldnâ€™t be using `uniq` in the first place! We
    will return to the issue of lists and duplicate elements in [Representing Sets
    as Lists](sets-from-lists.html).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.5Â `uniq`: Example and Code Variations[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, there are other example sequences you might have written
    down. Hereâ€™s a very different process:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the entire given list and with the empty answer (so far).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each list element, check whether itâ€™s already in the answer so far. If it
    is, ignore it, otherwise extend the answer with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are no more elements in the list, the answer so far is the answer
    for the whole list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that this solution assumes that we will be accumulating the answer as
    we traverse the list. Therefore, we canâ€™t even write the example with one parameter
    as we did before. We would argue that a natural solution asks whether we can solve
    the problem just from the structure of the data using the computation we are already
    defining, as we did above. If we cannot, then we have to resort to an accumulator.
    But because we can, the accumulator is unnecessary here and greatly complicates
    even writing down examples (give it a try!).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.6Â `uniq`: Why Produce a List?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you go back to the original statement of the `uniq` problem [[`uniq`: Problem
    Setup](#%28part._uniq%29)], youâ€™ll notice it said nothing about what order the
    output should have; in fact, it didnâ€™t even say the output needs to be a list
    (and hence have an order). In that case, we should think about whether a list
    even makes sense for this problem. In fact, if we donâ€™t care about order and donâ€™t
    want duplicates (by definition of `uniq`), then there is a much simpler solution,
    which is to produce a set. Pyret already has sets built in, and converting the
    list to a set automatically takes care of duplicates. This is of course cheating
    from the perspective of learning how to write `uniq`, but it is worth remembering
    that sometimes the right data structure to produce isnâ€™t necessarily the same
    as the one we were given. Also, later [[Representing Sets as Lists](sets-from-lists.html)],
    we will see how to build sets for ourselves (at which point, `uniq` will look
    familiar, since it is at the heart of set-ness).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.10Â Monomorphic Lists and Polymorphic Types[ğŸ”—](#(part._polymorphic-data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier we wrote contracts like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'These are unsatisfying for several reasons. Consider `my-max`. The contract
    suggests that any kind of element can be in the input list, but in fact that isnâ€™t
    true: the input `[list: 1, "two", 3]` is not valid, because we canâ€™t compare `1`
    with `"two"` or `"two"` with `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we run `1 > "two"` or `"two" > 3`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rather, what we mean is a list where all the elements are of the same kind,Technically,
    elements that are also comparable. and the contract has not captured that. Furthermore,
    we donâ€™t mean that `my-max` might return any old type: if we supply it with a
    list of numbers, we will not get a string as the maximum element! Rather, it will
    only return the kind of element that is in the provided list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we mean that all elements of the list are of the same type, but they
    can be of any type. We call the former monomorphic: â€œmonoâ€ meaning one, and â€œmorphicâ€
    meaning shape, i.e., all values have one type. But the function `my-max` itself
    can operate over many of these kinds of lists, so we call it polymorphic (â€œpolyâ€
    meaning many).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we need a better way of writing these contracts. Essentially, we
    want to say that there is a type variable (as opposed to regular program variable)
    that represents the type of element in the list. Given that type, `my-max` will
    return an element of that type. We write this syntactically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The notation `<T>` says that `T` is a type variable parameter that will be used
    in the rest of the function (both the header and the body).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this notation, we can also revisit `my-len`. Its header now becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `my-len` did not actually â€œcareâ€ that whether all the values were
    of the same type or not: it never looks at the individual elements, much less
    at pairs of them. However, as a convention we demand that lists always be monomorphic.
    This is important because it enables us to process the elements of the list uniformly:
    if we know how to process elements of type `T`, then we will know how to process
    a `List<T>`. If the list elements can be of truly any old type, we canâ€™t know
    how to process its elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1Â Making Lists and Taking Them Apart[ğŸ”—](#(part._.Making_.Lists_and_.Taking_.Them_.Apart)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far weâ€™ve seen one way to make a list: by writing `[list: â€¦]`. While useful,
    writing lists this way actually hides their true nature. Every list actually has
    two parts: a first element and the rest of the list. The rest of the list is itself
    a list, so it too has two partsâ€¦and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the list `[list: 1, 2, 3]`. Its first element is `1`, and the rest
    of it is `[list: 2, 3]`. For this second list, the first element is `2` and the
    rest is `[list: 3]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take apart this third list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For the third list, the first element is `3` and the rest is `[list: ]`, i.e.,
    the empty list. In Pyret, we have another way of writing the empty list: `empty`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are an instance of structured data: data with component parts and a well-defined
    format for the shape of the parts. Lists are formatted by the first element and
    the rest of the elements. Tables are somewhat structured: they are formatted by
    rows and columns, but the column names arenâ€™t consistent across all tables. Structured
    data is valuable in programming because a predictable format (the structure) lets
    us write programs based on that structure. What do we mean by that?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming languages can (and do!) provide built-in operators for taking apart
    structured data. These operators are called accessors. Accessors are defined on
    the structure of the datatype alone, independent of the contents of the data.
    In the case of lists, there are two accessors: `first` and `rest`. We use an accessor
    by writing an expression, followed by a dot (`.`), followed by the accessorâ€™s
    name. As we saw with tables, the dot means "dig into". Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the accessors for tables?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Accessors give a way to take data apart based on their structure (there is
    another way that we will see shortly). Is there a way to also build data based
    on its structure? So far, we have been building lists using the `[list: ...]`
    form, but that doesnâ€™t emphasize the structural constraint that the `rest` is
    itself a list. A structured operator for building lists would clearly show both
    a `first` element and a `rest` that is itself a list. Operators for building structured
    data are called constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for lists is called `link`. It takes two arguments: a `first`
    element, and the list to build on (the `rest` part). Hereâ€™s an example of using
    `link` to create a three-element list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The `link` form creates the same underlying list datum as our previous `[list:
    ...]` operation, as confirmed by the following check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look at these two forms of writing lists: what differences do you notice?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `link` form to write a four-element list of fruits containing `"lychee"`,
    `"dates"`, `"mango"`, and `"durian"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'After doing this exercise, you might wonder why anyone would use the `link`
    form: itâ€™s more verbose, and makes the individual elements harder to discern.
    This form is not very convenient to humans. But it will prove very valuable to
    programs!'
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the `link` form highlights that we really have two different
    structures of lists. Some lists are empty. All other lists are non-empty lists,
    meaning they have at least one `link`. There may be more interesting structure
    to some lists (as we will see later), but all lists have this much in common.
    Specifically, a list is either
  prefs: []
  type: TYPE_NORMAL
- en: 'empty (written `empty` or `[list: ]`), or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'non-empty (written `link(â€¦, â€¦)` or `[list: ]` with at least one value inside
    the brackets), where the rest is also a list (and hence may in turn be empty or
    non-empty, â€¦).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means we actually have two structural features of lists, both of which
    are important when writing programs over lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Lists can be empty or non-empty
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Non-empty lists have a first element and a rest of the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Letâ€™s leverage these two structural features to write some programs to process
    lists!
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2Â Some Example Exercises[ğŸ”—](#(part._my-len) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To illustrate our thinking, letâ€™s work through a few concrete examples of list-processing
    functions. All of these will consume lists; some will even produce them. Some
    will transform their inputs (like `map`), some will select from their inputs (like
    `filter`), and some will aggregate their inputs. Since some of these functions
    already exist in Pyret, weâ€™ll name them with the prefix `my-` to avoid errors.Be
    sure to use the `my-` name consistently, including inside the body of the function.
    As we will see, there is a standard strategy that we can use to approach writing
    all of these functions: having you learn this strategy is the goal of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3Â Structural Problems with Scalar Answers[ğŸ”—](#(part._.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Letâ€™s write out examples for a few of the functions described above. Weâ€™ll
    approach writing examples in a very specific, stylized way. First of all, we should
    always construct at least two examples: one with `empty` and the other with at
    least one `link`, so that weâ€™ve covered the two very broad kinds of lists. Then,
    we should have more examples specific to the kind of list stated in the problem.
    Finally, we should have even more examples to illustrate how we think about solving
    the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.3.1Â `my-len`: Examples[ğŸ”—](#(part._len-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a list. We confront
    this right away when trying to write an example. What is the length of the list
    `empty`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two common examples are `0` and `1`. The latter, `1`, certainly looks reasonable.
    However, if you write the list as `[list: ]`, now it doesnâ€™t look so right: this
    is clearly (as the name `empty` also suggests) an empty list, and an empty list
    has zero elements in it. Therefore, itâ€™s conventional to declare that'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'How about a list like `[list: 7]`? Well, itâ€™s clearly got one element (`7`)
    in it, so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for a list like `[list: 7, 8, 9]`, we would say'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now letâ€™s look at that last example in a different light. Consider the argument
    `[list: 7, 8, 9]`. Its first element is `7` and the rest of it is `[list: 8, 9]`.
    Well, `7` is a number, not a list; but `[list: 8, 9]` certainly is a list, so
    we can ask for its length. What is `my-len([list: 8, 9])`? It has two elements,
    so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of that list is `8` while its rest is `[list: 9]`. What is
    its length? Note that we asked a very similar question before, for the length
    of the list `[list: 7]`. But `[list: 7]` is not a sub-list of `[list: 7, 8, 9]`,
    which we started with, whereas `[list: 9]` is. And using the same reasoning as
    before, we can say'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The rest of this last list is, of course, the empty list, whose length we have
    already decided is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together these examples, and writing out `empty` in its other form,
    hereâ€™s what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Another way we can write this (paying attention to the right side) is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Where did the `2`, `1`, and `0` on the right sides of each `+` operation come
    from? Those are the lengths of the `rest` component of the input list. In the
    previous example block, we wrote those lengths as explicit examples. Letâ€™s substitute
    the numbers `2`, `1`, and `0` with the `my-len` expressions that produce them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: From this, maybe you can start to see a pattern. For an empty list, the length
    is `0`. For a non-empty list, itâ€™s the sum of `1` (the first elementâ€™s â€œcontributionâ€
    to the listâ€™s length) to the length of the rest of the list. In other words, we
    can use the result of computing `my-len` on the rest of the list to compute the
    answer for the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each of our examples in this section has written a different check on the expression
    `my-len([list: 7, 8, 9])`. Here are those examples presented together, along with
    one last one that explicitly uses the `rest` operation:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that you agree with each of these assertions. Also check whether you understand
    how the right-hand side of each `is` expression derives from the right-hand-side
    just above it. The goal of this exercise is to make sure that you believe that
    the last check (which we will turn into code) is equivalent to the first (which
    we wrote down when understanding the problem).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.3.2Â `my-sum`: Examples[ğŸ”—](#(part._sum-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s repeat this process of developing examples on a second function, this
    time one that computes the sum of the elements in a list of numbers. What is the
    sum of the list `[list: 7, 8, 9]`? Just adding up the numbers by hand, the result
    should be `24`. Letâ€™s see how that works out through the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting aside the empty list for a moment, here are examples that show the
    sum computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: which (by substitution) is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we can see that the sum of the empty list must be `0`:Zero is called
    the additive identity: a fancy way of saying, adding zero to any number N gives
    you N. Therefore, it makes sense that it would be the length of the empty list,
    because the empty list has no items to contribute to a sum. Can you figure out
    what the multiplicative identity is?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Observe, again, how we can use the result of computing `my-sum` of the rest
    of the list to compute its result for the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3.3Â From Examples to Code[ğŸ”—](#(part._.From_.Examples_to_.Code) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having developed these examples, we now want to use them to develop a program
    that can compute the length or the sum of any list, not just the specific ones
    we used in these examples. As we have done up in earlier chapters, we will leverage
    patterns in the examples to figure out how to define the general-purpose function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one last version of the examples for `my-len`, this time making the
    `rest` explicit on the right-hand sides of `is`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did when developing functions over images, letâ€™s try to identify the
    common parts of these examples. We start by noticing that most of the examples
    have a lot in common, except for the `[list: ]` (`empty`) case. So letâ€™s separate
    this into two sets of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'With this separation (which follows one of the structural features of lists
    that we mentioned earlier), a clearer pattern emerges: for a non-empty list (called
    `someList`), we compute its length via the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In general, then, our `my-len` program needs to determine whether its input
    list is empty or non-empty, using this expression with `.rest` in the non-empty
    case. How do we indicate different code based on the structure of the list?
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyret has a construct called `cases` which is used to distinguish different
    forms within a structured datatype. When working with lists, the general shape
    of a `cases` expression is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'where most parts are fixed, but a few youâ€™re free to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`e` is an expression whose value needs to be a list; it could be a variable
    bound to a list, or some complex expression that evaluates to a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` and `r` are names given to the first and rest of the list. You can choose
    any names you like, though in Pyret, itâ€™s conventional to use `f` and `r`.Occasionally
    using different names can help students recall that they can choose how to label
    the `first` and `rest` components. This can be particularly useful for `first`,
    which has a problem-specific meaning (such as `price` in a list of prices, and
    so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right-hand side of every `=>` is an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Hereâ€™s how `cases` works in this instance. Pyret first evaluates `e`. It then
    checks that the resulting value truly is a list; otherwise it halts with an error.
    If it is a list, Pyret examines what kind of list it is. If itâ€™s an empty list,
    it runs the expression after the `=>` in the `empty` clause. Otherwise, the list
    is not empty, which means it has a first and rest; Pyret binds `f` and `r` to
    the two parts, respectively, and then evaluates the expression after the `=>`
    in the `link` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try using a non-listâ€”<wbr>e.g., a numberâ€”<wbr>in the `e` position and see what
    happens!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now letâ€™s use `cases` to define `my-len`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows from our examples: when the list is empty `my-len` produces `0`;
    when it is not empty, we add one to the length of the rest of the list (here,
    `r`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while our most recent collection of `my-len` examples explicitly said
    `.rest`, when using `cases` we instead use just the name `r`, which Pyret has
    already defined (under the hood) to be `l.rest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, letâ€™s define `my-sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Notice how similar they are in code, and how readily the structure of the data
    suggest a structure for the program. This is a pattern you will get very used
    to soon!
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Developing Functions Over Lists'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage the structure of lists and the power of concrete examples to develop
    list-processing functions.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pick a concrete list with (at least) three elements. Write a sequence of examples
    for each of the entire list and each suffix of the list (including the empty list).
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Rewrite each example to express its expected answer in terms of the `first`
    and `rest` data of its input list. You donâ€™t have to use the `first` and `rest`
    operators in the new answers, but you should see the `first` and `rest` values
    represented explicitly in the answer.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look for a pattern across the answers in the examples. Use these to develop
    the code: write a `cases` expression, filling in the right side of each `=>` based
    on your examples.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This strategy applies to structured data in general, leveraging components of
    each datum rather than specifically `first` and `rest` as presented so far.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.3.1Â `my-len`: Examples[ğŸ”—](#(part._len-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a list. We confront
    this right away when trying to write an example. What is the length of the list
    `empty`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two common examples are `0` and `1`. The latter, `1`, certainly looks reasonable.
    However, if you write the list as `[list: ]`, now it doesnâ€™t look so right: this
    is clearly (as the name `empty` also suggests) an empty list, and an empty list
    has zero elements in it. Therefore, itâ€™s conventional to declare that'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'How about a list like `[list: 7]`? Well, itâ€™s clearly got one element (`7`)
    in it, so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for a list like `[list: 7, 8, 9]`, we would say'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now letâ€™s look at that last example in a different light. Consider the argument
    `[list: 7, 8, 9]`. Its first element is `7` and the rest of it is `[list: 8, 9]`.
    Well, `7` is a number, not a list; but `[list: 8, 9]` certainly is a list, so
    we can ask for its length. What is `my-len([list: 8, 9])`? It has two elements,
    so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of that list is `8` while its rest is `[list: 9]`. What is
    its length? Note that we asked a very similar question before, for the length
    of the list `[list: 7]`. But `[list: 7]` is not a sub-list of `[list: 7, 8, 9]`,
    which we started with, whereas `[list: 9]` is. And using the same reasoning as
    before, we can say'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The rest of this last list is, of course, the empty list, whose length we have
    already decided is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together these examples, and writing out `empty` in its other form,
    hereâ€™s what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Another way we can write this (paying attention to the right side) is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Where did the `2`, `1`, and `0` on the right sides of each `+` operation come
    from? Those are the lengths of the `rest` component of the input list. In the
    previous example block, we wrote those lengths as explicit examples. Letâ€™s substitute
    the numbers `2`, `1`, and `0` with the `my-len` expressions that produce them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: From this, maybe you can start to see a pattern. For an empty list, the length
    is `0`. For a non-empty list, itâ€™s the sum of `1` (the first elementâ€™s â€œcontributionâ€
    to the listâ€™s length) to the length of the rest of the list. In other words, we
    can use the result of computing `my-len` on the rest of the list to compute the
    answer for the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each of our examples in this section has written a different check on the expression
    `my-len([list: 7, 8, 9])`. Here are those examples presented together, along with
    one last one that explicitly uses the `rest` operation:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that you agree with each of these assertions. Also check whether you understand
    how the right-hand side of each `is` expression derives from the right-hand-side
    just above it. The goal of this exercise is to make sure that you believe that
    the last check (which we will turn into code) is equivalent to the first (which
    we wrote down when understanding the problem).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.3.2Â `my-sum`: Examples[ğŸ”—](#(part._sum-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s repeat this process of developing examples on a second function, this
    time one that computes the sum of the elements in a list of numbers. What is the
    sum of the list `[list: 7, 8, 9]`? Just adding up the numbers by hand, the result
    should be `24`. Letâ€™s see how that works out through the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting aside the empty list for a moment, here are examples that show the
    sum computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: which (by substitution) is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we can see that the sum of the empty list must be `0`:Zero is called
    the additive identity: a fancy way of saying, adding zero to any number N gives
    you N. Therefore, it makes sense that it would be the length of the empty list,
    because the empty list has no items to contribute to a sum. Can you figure out
    what the multiplicative identity is?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Observe, again, how we can use the result of computing `my-sum` of the rest
    of the list to compute its result for the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3.3Â From Examples to Code[ğŸ”—](#(part._.From_.Examples_to_.Code) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having developed these examples, we now want to use them to develop a program
    that can compute the length or the sum of any list, not just the specific ones
    we used in these examples. As we have done up in earlier chapters, we will leverage
    patterns in the examples to figure out how to define the general-purpose function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one last version of the examples for `my-len`, this time making the
    `rest` explicit on the right-hand sides of `is`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did when developing functions over images, letâ€™s try to identify the
    common parts of these examples. We start by noticing that most of the examples
    have a lot in common, except for the `[list: ]` (`empty`) case. So letâ€™s separate
    this into two sets of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'With this separation (which follows one of the structural features of lists
    that we mentioned earlier), a clearer pattern emerges: for a non-empty list (called
    `someList`), we compute its length via the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: In general, then, our `my-len` program needs to determine whether its input
    list is empty or non-empty, using this expression with `.rest` in the non-empty
    case. How do we indicate different code based on the structure of the list?
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyret has a construct called `cases` which is used to distinguish different
    forms within a structured datatype. When working with lists, the general shape
    of a `cases` expression is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'where most parts are fixed, but a few youâ€™re free to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`e` is an expression whose value needs to be a list; it could be a variable
    bound to a list, or some complex expression that evaluates to a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` and `r` are names given to the first and rest of the list. You can choose
    any names you like, though in Pyret, itâ€™s conventional to use `f` and `r`.Occasionally
    using different names can help students recall that they can choose how to label
    the `first` and `rest` components. This can be particularly useful for `first`,
    which has a problem-specific meaning (such as `price` in a list of prices, and
    so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right-hand side of every `=>` is an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Hereâ€™s how `cases` works in this instance. Pyret first evaluates `e`. It then
    checks that the resulting value truly is a list; otherwise it halts with an error.
    If it is a list, Pyret examines what kind of list it is. If itâ€™s an empty list,
    it runs the expression after the `=>` in the `empty` clause. Otherwise, the list
    is not empty, which means it has a first and rest; Pyret binds `f` and `r` to
    the two parts, respectively, and then evaluates the expression after the `=>`
    in the `link` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try using a non-listâ€”<wbr>e.g., a numberâ€”<wbr>in the `e` position and see what
    happens!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now letâ€™s use `cases` to define `my-len`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows from our examples: when the list is empty `my-len` produces `0`;
    when it is not empty, we add one to the length of the rest of the list (here,
    `r`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while our most recent collection of `my-len` examples explicitly said
    `.rest`, when using `cases` we instead use just the name `r`, which Pyret has
    already defined (under the hood) to be `l.rest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, letâ€™s define `my-sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Notice how similar they are in code, and how readily the structure of the data
    suggest a structure for the program. This is a pattern you will get very used
    to soon!
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Developing Functions Over Lists'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage the structure of lists and the power of concrete examples to develop
    list-processing functions.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pick a concrete list with (at least) three elements. Write a sequence of examples
    for each of the entire list and each suffix of the list (including the empty list).
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Rewrite each example to express its expected answer in terms of the `first`
    and `rest` data of its input list. You donâ€™t have to use the `first` and `rest`
    operators in the new answers, but you should see the `first` and `rest` values
    represented explicitly in the answer.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look for a pattern across the answers in the examples. Use these to develop
    the code: write a `cases` expression, filling in the right side of each `=>` based
    on your examples.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This strategy applies to structured data in general, leveraging components of
    each datum rather than specifically `first` and `rest` as presented so far.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.2.4Â Structural Problems that Transform Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Transform_.Lists)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have a systematic way to develop functions that take lists as input,
    letâ€™s apply that same strategy to functions that produce a list as the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.4.1Â `my-doubles`: Examples and Code[ğŸ”—](#(part._doubles-eg-code) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As always, weâ€™ll begin with some examples. Given a list of numbers, we want
    a list that doubles each number (in the order of the original list). Hereâ€™s a
    reasonable example with three numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, letâ€™s write out the answers for each suffix of our example list
    as well, including for the `empty` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rewrite the answer expressions to include the concrete `first` and
    `rest` data for each example. Letâ€™s start with just the `first` data, and just
    on the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, letâ€™s include the `rest` data (`[list: 5, 2]`) in the first example.
    The current answer in the first example is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'and that `[list: 10, 4]` is the result of using the function on `[list: 5,
    2]`. We might therefore be tempted to replace the right side of the first example
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What value would this expression produce? You might want to try this example
    that doesnâ€™t use `my-doubles` directly:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Oops! We want a single (flat) list, not a list-within-a-list. This feels like
    it is on the right track in terms of reworking the answer to use the `first` and
    `rest` values, but weâ€™re clearly not quite there yet.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value does the following expression produce?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 'Notice the difference between the two expressions in these last two exercises:
    the latter used `link` to put the value involving `first` into the conversion
    of the `rest`, while the former tried to do this with `list:`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many elements are in the lists that result from each of the following expressions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summarize the difference between how `link` and `list:` combine an element and
    a list. Try additional examples at the interactions prompt if needed to explore
    these ideas.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The takeaway here is that we use `link` to insert an element into an existing
    list, whereas we use `list:` to make a new list that contains the old list as
    an element. Going back to our examples, then, we include `rest` in the first example
    by writing it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: which we then convert to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this idea across the examples, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have examples that explicitly use the `first` and `rest` elements,
    we can produce to write the `my-doubles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '5.2.4.2Â `my-str-len`: Examples and Code[ğŸ”—](#(part._str-len-eg-code) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In `my-doubles`, the input and output lists have the same type of element.
    Functions can also produce lists whose contents have a different type from the
    input list. Letâ€™s work through an example. Given a list of strings, we want the
    lengths of each string (in the same order as in the input list). Thus, hereâ€™s
    a reasonable example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have before, we should consider the answers for each sub-problem of the
    above example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'which tells us that the response for the empty list should be `empty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to rework the answers in the examples to make the `first`
    and `rest` parts explicit. Hopefully by now you are starting to detect a pattern:
    The result on the rest of the list appears explicitly as another example. Therefore,
    weâ€™ll start by getting the `rest` value of each example input into the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains now is to figure out how to work the `first` values into the
    outputs. In the context of this problem, this means we need to convert `"hi"`
    into `2`, `"there"` into `5`, and so on. From the problem statement, we know that
    `2` and `5` are meant to be the lengths (character counts) of the corresponding
    strings. The operation that determines the length of a string is called `string-length`.
    Thus, our examples appear as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we write a function that captures the pattern developed across our
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '5.2.4.1Â `my-doubles`: Examples and Code[ğŸ”—](#(part._doubles-eg-code) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As always, weâ€™ll begin with some examples. Given a list of numbers, we want
    a list that doubles each number (in the order of the original list). Hereâ€™s a
    reasonable example with three numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, letâ€™s write out the answers for each suffix of our example list
    as well, including for the `empty` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rewrite the answer expressions to include the concrete `first` and
    `rest` data for each example. Letâ€™s start with just the `first` data, and just
    on the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, letâ€™s include the `rest` data (`[list: 5, 2]`) in the first example.
    The current answer in the first example is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'and that `[list: 10, 4]` is the result of using the function on `[list: 5,
    2]`. We might therefore be tempted to replace the right side of the first example
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What value would this expression produce? You might want to try this example
    that doesnâ€™t use `my-doubles` directly:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Oops! We want a single (flat) list, not a list-within-a-list. This feels like
    it is on the right track in terms of reworking the answer to use the `first` and
    `rest` values, but weâ€™re clearly not quite there yet.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value does the following expression produce?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 'Notice the difference between the two expressions in these last two exercises:
    the latter used `link` to put the value involving `first` into the conversion
    of the `rest`, while the former tried to do this with `list:`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many elements are in the lists that result from each of the following expressions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summarize the difference between how `link` and `list:` combine an element and
    a list. Try additional examples at the interactions prompt if needed to explore
    these ideas.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The takeaway here is that we use `link` to insert an element into an existing
    list, whereas we use `list:` to make a new list that contains the old list as
    an element. Going back to our examples, then, we include `rest` in the first example
    by writing it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: which we then convert to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this idea across the examples, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have examples that explicitly use the `first` and `rest` elements,
    we can produce to write the `my-doubles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '5.2.4.2Â `my-str-len`: Examples and Code[ğŸ”—](#(part._str-len-eg-code) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In `my-doubles`, the input and output lists have the same type of element.
    Functions can also produce lists whose contents have a different type from the
    input list. Letâ€™s work through an example. Given a list of strings, we want the
    lengths of each string (in the same order as in the input list). Thus, hereâ€™s
    a reasonable example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have before, we should consider the answers for each sub-problem of the
    above example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'which tells us that the response for the empty list should be `empty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to rework the answers in the examples to make the `first`
    and `rest` parts explicit. Hopefully by now you are starting to detect a pattern:
    The result on the rest of the list appears explicitly as another example. Therefore,
    weâ€™ll start by getting the `rest` value of each example input into the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains now is to figure out how to work the `first` values into the
    outputs. In the context of this problem, this means we need to convert `"hi"`
    into `2`, `"there"` into `5`, and so on. From the problem statement, we know that
    `2` and `5` are meant to be the lengths (character counts) of the corresponding
    strings. The operation that determines the length of a string is called `string-length`.
    Thus, our examples appear as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we write a function that captures the pattern developed across our
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 5.2.5Â Structural Problems that Select from Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Select_from_.Lists)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the previous section, we saw functions that transform list elements (by
    doubling numbers or counting characters). The type of the output list may or may
    not be the same as the type of the input list. Other functions that produce lists
    instead select elements: every element in the output list was in the input list,
    but some input-list elements might not appear in the output list. This section
    adapts our method of deriving functions from examples to accommodate selection
    of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.5.1Â `my-pos-nums`: Examples and Code[ğŸ”—](#(part._pos-nums-eg-code) "Link
    to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As our first example, we will select the positive numbers from a list that contains
    both positive and non-positive numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct the sequence of examples that we obtain from the input `[list: 1,
    -2, 3, -4]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write this in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: or, even more explicitly,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike in the example sequences for functions that transform lists, here we
    see that the answers have different shapes: some involve a `link`, while others
    simply process the `rest` of the list. Whenever we need different shapes of outputs
    across a set of examples, we will need an `if` expression in our code to distinguish
    the conditions that yield each shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What determines which shape of output we get? Letâ€™s rearrange the examples
    (other than the empty-list input) by output shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Re-organized, we can see that the examples that use `link` have a positive
    number in the `first` position, while the ones that donâ€™t simply process the `rest`
    of the list. That indicates that our `if` expression needs to ask whether the
    `first` element in the list is positive. This yields the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is our set of examples comprehensive?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not really. There are many examples we havenâ€™t considered, such as lists that
    end with positive numbers and lists with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through these examples and see how they affect the program!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.5.2Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-eg-code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now letâ€™s consider a problem that selects elements not by value, but by position.
    We want to write a function that selects alternating elements from a list. Once
    again, weâ€™re going to work from examples.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-alternating` starting from the list `[list: 1,
    2, 3, 4, 5, 6]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hereâ€™s how they work out:'
  prefs: []
  type: TYPE_NORMAL
- en: <alternating-egs-1> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait, whatâ€™s that? The two answers above are each correct, but the second answer
    does not help us in any way construct the first answer. That means the way weâ€™ve
    solved these problems until now is not enough for this new kind of problem. Itâ€™s
    still useful, though: notice that thereâ€™s a connection between the first example
    and the third, as well as between the second example and the fourth. This observation
    is consistent with our goal of selecting alternating elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What would something like this look like in code? Before we try to write the
    function, letâ€™s rewrite the first example in terms of the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the rewritten version, we are dropping two elements from the list
    before using `my-alternating` again, not just one. We will have to figure out
    how to handle that in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s start with our usual function pattern with a `cases` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we cannot simply call `my-alternating` on `r`, because `r` excludes
    only one item from the list, not two as this problem requires. We have to break
    down `r` as well, in order to get to the `rest` of the `rest` of the original
    list. To do this, we use another `cases` expression, nested within the first `cases`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is consistent with the example that we just worked out. But note
    that we still have a bit of unfinished work to do: we need to decide what to do
    in the `empty` case of the inner `cases` expression (marked by `???` in the code).'
  prefs: []
  type: TYPE_NORMAL
- en: A common temptation at this point is to replace the `???` with `[list:]`. After
    all, havenâ€™t we always returned `[list:]` in the `empty` cases?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Replace `???` with `[list:]` and test the program on our original examples:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you observe?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Oops! Weâ€™ve written a program that appears to work on lists with an even number
    of elements, but not on lists with an odd number of elements. How did that happen?
    The only part of this code that we guessed at was how to fill in the `empty` case
    of the inner `cases`, so the issue must be there. Rather than focus on the code,
    however, focus on the examples. We need a simple example that would land on that
    part of the code. We get to that spot when the list `l` is not empty, but `r`
    (the rest of `l`) is empty. In other words, we need an example with only one element.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finish the following example:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Given a list with one element, that element should be included in a list of
    alternating elements. Thus, we should finish this example as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this example to update the result of `my-alternating` when `r` is `empty`
    in our code.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Leveraging this new example, the final version of `my-alternating` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatâ€™s the takeaway from this problem? There are two:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Donâ€™t skip the small examples: the result of a list-processing function on
    the `empty` case wonâ€™t always be `empty`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a problem asks you to work with multiple elements from the front of a list,
    you can nest `cases` expressions to access later elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These takeaways will matter again in future examples: keep an eye out for them!'
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.5.1Â `my-pos-nums`: Examples and Code[ğŸ”—](#(part._pos-nums-eg-code) "Link
    to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As our first example, we will select the positive numbers from a list that contains
    both positive and non-positive numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct the sequence of examples that we obtain from the input `[list: 1,
    -2, 3, -4]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write this in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: or, even more explicitly,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike in the example sequences for functions that transform lists, here we
    see that the answers have different shapes: some involve a `link`, while others
    simply process the `rest` of the list. Whenever we need different shapes of outputs
    across a set of examples, we will need an `if` expression in our code to distinguish
    the conditions that yield each shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What determines which shape of output we get? Letâ€™s rearrange the examples
    (other than the empty-list input) by output shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Re-organized, we can see that the examples that use `link` have a positive
    number in the `first` position, while the ones that donâ€™t simply process the `rest`
    of the list. That indicates that our `if` expression needs to ask whether the
    `first` element in the list is positive. This yields the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is our set of examples comprehensive?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not really. There are many examples we havenâ€™t considered, such as lists that
    end with positive numbers and lists with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through these examples and see how they affect the program!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.5.2Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-eg-code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now letâ€™s consider a problem that selects elements not by value, but by position.
    We want to write a function that selects alternating elements from a list. Once
    again, weâ€™re going to work from examples.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-alternating` starting from the list `[list: 1,
    2, 3, 4, 5, 6]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hereâ€™s how they work out:'
  prefs: []
  type: TYPE_NORMAL
- en: <alternating-egs-1> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait, whatâ€™s that? The two answers above are each correct, but the second answer
    does not help us in any way construct the first answer. That means the way weâ€™ve
    solved these problems until now is not enough for this new kind of problem. Itâ€™s
    still useful, though: notice that thereâ€™s a connection between the first example
    and the third, as well as between the second example and the fourth. This observation
    is consistent with our goal of selecting alternating elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What would something like this look like in code? Before we try to write the
    function, letâ€™s rewrite the first example in terms of the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the rewritten version, we are dropping two elements from the list
    before using `my-alternating` again, not just one. We will have to figure out
    how to handle that in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s start with our usual function pattern with a `cases` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we cannot simply call `my-alternating` on `r`, because `r` excludes
    only one item from the list, not two as this problem requires. We have to break
    down `r` as well, in order to get to the `rest` of the `rest` of the original
    list. To do this, we use another `cases` expression, nested within the first `cases`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is consistent with the example that we just worked out. But note
    that we still have a bit of unfinished work to do: we need to decide what to do
    in the `empty` case of the inner `cases` expression (marked by `???` in the code).'
  prefs: []
  type: TYPE_NORMAL
- en: A common temptation at this point is to replace the `???` with `[list:]`. After
    all, havenâ€™t we always returned `[list:]` in the `empty` cases?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Replace `???` with `[list:]` and test the program on our original examples:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you observe?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Oops! Weâ€™ve written a program that appears to work on lists with an even number
    of elements, but not on lists with an odd number of elements. How did that happen?
    The only part of this code that we guessed at was how to fill in the `empty` case
    of the inner `cases`, so the issue must be there. Rather than focus on the code,
    however, focus on the examples. We need a simple example that would land on that
    part of the code. We get to that spot when the list `l` is not empty, but `r`
    (the rest of `l`) is empty. In other words, we need an example with only one element.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finish the following example:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Given a list with one element, that element should be included in a list of
    alternating elements. Thus, we should finish this example as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this example to update the result of `my-alternating` when `r` is `empty`
    in our code.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Leveraging this new example, the final version of `my-alternating` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatâ€™s the takeaway from this problem? There are two:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Donâ€™t skip the small examples: the result of a list-processing function on
    the `empty` case wonâ€™t always be `empty`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a problem asks you to work with multiple elements from the front of a list,
    you can nest `cases` expressions to access later elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These takeaways will matter again in future examples: keep an eye out for them!'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.6Â Structural Problems Over Relaxed Domains[ğŸ”—](#(part._struct-prob-sub-dom)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '5.2.6.1Â `my-max`: Examples[ğŸ”—](#(part._my-max) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now letâ€™s find the maximum value of a list. Letâ€™s assume for simplicity that
    weâ€™re dealing with just lists of numbers. What kinds of lists should we construct?
    Clearly, we should have empty and non-empty listsâ€¦but what else? Is a list like
    `[list: 1, 2, 3]` a good example? Well, thereâ€™s nothing wrong with it, but we
    should also consider lists where the maximum is at the beginning rather than at
    the end; the maximum might be in the middle; the maximum might be repeated; the
    maximum might be negative; and so on. While not comprehensive, here is a small
    but interesting set of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: What about `my-max(empty)`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Could we define `my-max(empty)` to be `0`? Returning `0` for the empty list
    has worked well twice already!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Weâ€™ll return to this in a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, itâ€™s useful to know that thereâ€™s a function called `num-max`
    already defined in Pyret, that compares two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose `num-max` were not already built in. Can you define it? You will find
    what you learned about [Booleans](Conditionals_and_Booleans.html#%28part._booleans%29)
    handy. Remember to write some tests!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now we can look at `my-max` at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be sure.
    And we still donâ€™t know what to do with `empty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s try the second example input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually telling us something useful as well, but maybe we canâ€™t see
    it yet. Letâ€™s take on something more ambitious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how the maximum of the rest of the list gives us a candidate answer,
    but comparing it to the first element gives us a definitive one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'The last one is a little awkward: weâ€™d like to write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: but we donâ€™t really know what the maximum (or minimum, or any other element)
    of the empty list is, but we can only provide numbers to `num-max`. Therefore,
    leaving out that dodgy case, weâ€™re left with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Our examples have again helped: theyâ€™ve revealed how we can use the answer
    for each rest of the list to compute the answer for the whole list, which in turn
    is the rest of some other list, and so on. If you go back and look at the other
    example lists we wrote above, youâ€™ll see the pattern holds there too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, itâ€™s time we now confront the `empty` case. The real problem is that
    we donâ€™t have a maximum for the empty list: for any number we might provide, there
    is always a number bigger than it (assuming our computer is large enough) that
    could have been the answer instead. In short, itâ€™s nonsensical to ask for the
    maximum (or minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
    on non-empty lists! That is, when asked for the maximum of an empty list, we should
    signal an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: (which is how, in Pyret, we say that it will generate an error; we donâ€™t care
    about the details of the error, hence the empty string).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.6.2Â `my-max`: From Examples to Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once again, we can codify the examples above, i.e., turn them into a uniform
    program that works for all instances. However, we now have a twist. If we blindly
    followed the pattern weâ€™ve used earlier, we would end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s wrong with this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Consider the list `[list: 2]`. This turns into'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: which of course raises an error. Therefore, this function never works for any
    list that has one or more elements!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thatâ€™s because we need to make sure we arenâ€™t trying to compute the maximum
    of the empty list. Going back to our examples, we see that what we need to do,
    before calling `my-max`, is check whether the rest of the list is empty. If it
    is, we do not want to call `my-max` at all. That is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Weâ€™ll return to what to do when the rest is not empty in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the rest of the list `l` is empty, our examples above tell us that the maximum
    is the first element in the list. Therefore, we can fill this in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in particular the absence of a call to `my-max`. If the list is not empty,
    however, our examples above tell us that `my-max` will give us the maximum of
    the rest of the list, and we just need to compare this answer with the first element
    (`f`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, this definition does the job!
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.6.1Â `my-max`: Examples[ğŸ”—](#(part._my-max) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now letâ€™s find the maximum value of a list. Letâ€™s assume for simplicity that
    weâ€™re dealing with just lists of numbers. What kinds of lists should we construct?
    Clearly, we should have empty and non-empty listsâ€¦but what else? Is a list like
    `[list: 1, 2, 3]` a good example? Well, thereâ€™s nothing wrong with it, but we
    should also consider lists where the maximum is at the beginning rather than at
    the end; the maximum might be in the middle; the maximum might be repeated; the
    maximum might be negative; and so on. While not comprehensive, here is a small
    but interesting set of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: What about `my-max(empty)`?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Could we define `my-max(empty)` to be `0`? Returning `0` for the empty list
    has worked well twice already!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Weâ€™ll return to this in a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, itâ€™s useful to know that thereâ€™s a function called `num-max`
    already defined in Pyret, that compares two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose `num-max` were not already built in. Can you define it? You will find
    what you learned about [Booleans](Conditionals_and_Booleans.html#%28part._booleans%29)
    handy. Remember to write some tests!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now we can look at `my-max` at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be sure.
    And we still donâ€™t know what to do with `empty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s try the second example input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually telling us something useful as well, but maybe we canâ€™t see
    it yet. Letâ€™s take on something more ambitious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how the maximum of the rest of the list gives us a candidate answer,
    but comparing it to the first element gives us a definitive one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'The last one is a little awkward: weâ€™d like to write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: but we donâ€™t really know what the maximum (or minimum, or any other element)
    of the empty list is, but we can only provide numbers to `num-max`. Therefore,
    leaving out that dodgy case, weâ€™re left with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Our examples have again helped: theyâ€™ve revealed how we can use the answer
    for each rest of the list to compute the answer for the whole list, which in turn
    is the rest of some other list, and so on. If you go back and look at the other
    example lists we wrote above, youâ€™ll see the pattern holds there too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, itâ€™s time we now confront the `empty` case. The real problem is that
    we donâ€™t have a maximum for the empty list: for any number we might provide, there
    is always a number bigger than it (assuming our computer is large enough) that
    could have been the answer instead. In short, itâ€™s nonsensical to ask for the
    maximum (or minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
    on non-empty lists! That is, when asked for the maximum of an empty list, we should
    signal an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: (which is how, in Pyret, we say that it will generate an error; we donâ€™t care
    about the details of the error, hence the empty string).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.6.2Â `my-max`: From Examples to Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once again, we can codify the examples above, i.e., turn them into a uniform
    program that works for all instances. However, we now have a twist. If we blindly
    followed the pattern weâ€™ve used earlier, we would end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s wrong with this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Consider the list `[list: 2]`. This turns into'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: which of course raises an error. Therefore, this function never works for any
    list that has one or more elements!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thatâ€™s because we need to make sure we arenâ€™t trying to compute the maximum
    of the empty list. Going back to our examples, we see that what we need to do,
    before calling `my-max`, is check whether the rest of the list is empty. If it
    is, we do not want to call `my-max` at all. That is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Weâ€™ll return to what to do when the rest is not empty in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the rest of the list `l` is empty, our examples above tell us that the maximum
    is the first element in the list. Therefore, we can fill this in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in particular the absence of a call to `my-max`. If the list is not empty,
    however, our examples above tell us that `my-max` will give us the maximum of
    the rest of the list, and we just need to compare this answer with the first element
    (`f`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, this definition does the job!
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.7Â More Structural Problems with Scalar Answers[ğŸ”—](#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '5.2.7.1Â `my-avg`: Examples[ğŸ”—](#(part._avg-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start with
    the example list `[list: 1, 2, 3, 4]` and work out more examples from it. The
    average of numbers in this list is clearly `(1 + 2 + 3 + 4)/4`, or `10/4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the listâ€™s structure, we see that the rest of the list is `[list:
    2, 3, 4]`, and the rest of that is `[list: 3, 4]`, and so on. The resulting averages
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is, itâ€™s simply not clear how we get from the answer for the sub-list
    to the answer for the whole list. That is, given the following two bits of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The average of the remainder of the list is `9/3`, i.e., `3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first number in the list is `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we determine that the average of the whole list must be `10/4`? If itâ€™s
    not clear to you, donâ€™t worry: with just those two pieces of information, itâ€™s
    impossible!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first value in
    a list is `1`, and the average of the rest of the list is `2`. Here are two very
    different lists that fit this description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: The average of the entire first list is `3/2`, while the average of the entire
    second list is `5/3`, and the two are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: That is, to compute the average of a whole list, itâ€™s not even useful to know
    the average of the rest of the list. Rather, we need to know the sum and the length
    of the rest of the list. With these two, we can add the first to the sum, and
    `1` to the length, and compute the new average.
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, we could try to make a `average` function that returns all this
    information. Instead, it will be a lot simpler to simply decompose the task into
    two smaller tasks. After all, we have already seen how to compute the length and
    how to compute the sum. The average, therefore, can just use these existing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be the average of the empty list? Does the above code produce what
    you would expect?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Just as we argued earlier about the maximum [[Structural Problems Over Relaxed
    Domains](#%28part._struct-prob-sub-dom%29)], the average of the empty list isnâ€™t
    a well-defined concept. Therefore, it would be appropriate to signal an error.
    The implementation above does this, but poorly: it reports an error on division.
    A better programming practice would be to catch this situation and report the
    error right away, rather than hoping some other function will report the error.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alter `my-avg` above to signal an error when given the empty list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Therefore, we see that the process weâ€™ve usedâ€”<wbr>of inferring code from examplesâ€”<wbr>wonâ€™t
    always suffice, and weâ€™ll need more sophisticated techniques to solve some problems.
    However, notice that working from examples helps us quickly identify situations
    where this approach does and doesnâ€™t work. Furthermore, if you look more closely
    youâ€™ll notice that the examples above do hint at how to solve the problem: in
    our very first examples, we wrote answers like `10/4`, `9/3`, and `7/2`, which
    correspond to the sum of the numbers divided by the length. Thus, writing the
    answers in this form (as opposed, for instance, to writing the second of those
    as `3`) already reveals a structure for a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.7.1Â `my-avg`: Examples[ğŸ”—](#(part._avg-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start with
    the example list `[list: 1, 2, 3, 4]` and work out more examples from it. The
    average of numbers in this list is clearly `(1 + 2 + 3 + 4)/4`, or `10/4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the listâ€™s structure, we see that the rest of the list is `[list:
    2, 3, 4]`, and the rest of that is `[list: 3, 4]`, and so on. The resulting averages
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is, itâ€™s simply not clear how we get from the answer for the sub-list
    to the answer for the whole list. That is, given the following two bits of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The average of the remainder of the list is `9/3`, i.e., `3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first number in the list is `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we determine that the average of the whole list must be `10/4`? If itâ€™s
    not clear to you, donâ€™t worry: with just those two pieces of information, itâ€™s
    impossible!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first value in
    a list is `1`, and the average of the rest of the list is `2`. Here are two very
    different lists that fit this description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The average of the entire first list is `3/2`, while the average of the entire
    second list is `5/3`, and the two are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: That is, to compute the average of a whole list, itâ€™s not even useful to know
    the average of the rest of the list. Rather, we need to know the sum and the length
    of the rest of the list. With these two, we can add the first to the sum, and
    `1` to the length, and compute the new average.
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, we could try to make a `average` function that returns all this
    information. Instead, it will be a lot simpler to simply decompose the task into
    two smaller tasks. After all, we have already seen how to compute the length and
    how to compute the sum. The average, therefore, can just use these existing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be the average of the empty list? Does the above code produce what
    you would expect?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Just as we argued earlier about the maximum [[Structural Problems Over Relaxed
    Domains](#%28part._struct-prob-sub-dom%29)], the average of the empty list isnâ€™t
    a well-defined concept. Therefore, it would be appropriate to signal an error.
    The implementation above does this, but poorly: it reports an error on division.
    A better programming practice would be to catch this situation and report the
    error right away, rather than hoping some other function will report the error.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alter `my-avg` above to signal an error when given the empty list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Therefore, we see that the process weâ€™ve usedâ€”<wbr>of inferring code from examplesâ€”<wbr>wonâ€™t
    always suffice, and weâ€™ll need more sophisticated techniques to solve some problems.
    However, notice that working from examples helps us quickly identify situations
    where this approach does and doesnâ€™t work. Furthermore, if you look more closely
    youâ€™ll notice that the examples above do hint at how to solve the problem: in
    our very first examples, we wrote answers like `10/4`, `9/3`, and `7/2`, which
    correspond to the sum of the numbers divided by the length. Thus, writing the
    answers in this form (as opposed, for instance, to writing the second of those
    as `3`) already reveals a structure for a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.8Â Structural Problems with Accumulators[ğŸ”—](#(part._accumulators) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '5.2.8.1Â `my-running-sum`: First Attempt[ğŸ”—](#(part._running-sum-1st-attempt)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One more time, weâ€™ll begin with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-running-sum` starting from the list `[list: 1,
    2, 3, 4, 5]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hereâ€™s what our first few examples look like:'
  prefs: []
  type: TYPE_NORMAL
- en: <running-sum-egs-1> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Again, there doesnâ€™t appear to be any clear connection between the result on
    the rest of the list and the result on the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: '(That isnâ€™t strictly true: we can still line up the answers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: and observe that weâ€™re computing the answer for the rest of the list, then adding
    the first element to each element in the answer, and `link`ing the first element
    to the front. In principle, we can compute this solution directly, but for now
    that may be more work than finding a simpler way to answer it.)
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.8.2Â `my-running-sum`: Examples and Code[ğŸ”—](#(part._running-sum-eg-code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall how we began in [`my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29).
    Our examples [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] showed the
    following problem. When we process the rest of the list, we have forgotten everything
    about what preceded it. That is, when processing the list starting at `2` we forget
    that weâ€™ve seen a `1` earlier; when starting from `3`, we forget that weâ€™ve seen
    both `1` and `2` earlier; and so on. In other words, we keep forgetting the past.
    We need some way of avoiding that.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest thing we can do is simply change our function to carry along this
    â€œmemoryâ€, or what weâ€™ll call an accumulator. That is, imagine we were defining
    a new function, called `my-rs`. It will consume a list of numbers and produce
    a list of numbers, but in addition it will also take the sum of numbers preceding
    the current list.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should the initial sum be?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Initially there is no â€œpreceding listâ€, so we will use the additive identity:
    `0`. The type of `my-rs` is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s now re-work our examples from [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)
    as examples of `my-rs` instead. The examples use the `+` operator to append two
    lists into one (the elements of the first list followed by the elements of the
    second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, `my-rs` translates into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'All thatâ€™s then left is to call it from `my-running-sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Observe that we do not change `my-running-sum` itself to take extra arguments.
    The correctness of our code depends on the initial value of `acc` being 0\. If
    we added a parameter for `acc`, any code that calls `my-running-sum` could supply
    an unexpected value, which would distort the result. In addition, since the value
    is fixed, adding the parameter would amount to shifting additional (and needless)
    work onto others who use our code.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.8.3Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-accumulator)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall our examples in [`my-alternating`: Examples and Code](#%28part._alternating-eg-code%29).
    There, we noticed that the code built on every-other example. We might have chosen
    our examples differently, so that from one example to the next we skipped two
    elements rather than one. Here we will see another way to think about the same
    problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the examples weâ€™ve already seen [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)].
    We wrote `my-alternating` to traverse the list essentially two elements at a time.
    Another option is to traverse it just one element at a time, but keeping track
    of whether weâ€™re at an odd or even elementâ€”<wbr>i.e., add â€œmemoryâ€ to our program.
    Since we just need to track that one piece of information, we can use a `Boolean`
    to do it. Letâ€™s define a new function for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: The extra argument accumulates whether weâ€™re at an element to keep or one to
    discard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the existing template for list functions. When we have an element,
    we have to consult the accumulator whether to keep it or not. If its value is
    `true` we `link` it to the answer; otherwise we ignore it. As we process the rest
    of the list, however, we have to remember to update the accumulator: if we kept
    an element we donâ€™t wish to keep the next one, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to determine the initial value of the accumulator. In this
    case, since we want to keep alternating elements starting with the first one,
    its initial value should be `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `my-max` using an accumulator. What does the accumulator represent? Do
    you encounter any difficulty?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.8.1Â `my-running-sum`: First Attempt[ğŸ”—](#(part._running-sum-1st-attempt)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One more time, weâ€™ll begin with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-running-sum` starting from the list `[list: 1,
    2, 3, 4, 5]`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hereâ€™s what our first few examples look like:'
  prefs: []
  type: TYPE_NORMAL
- en: <running-sum-egs-1> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Again, there doesnâ€™t appear to be any clear connection between the result on
    the rest of the list and the result on the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: '(That isnâ€™t strictly true: we can still line up the answers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: and observe that weâ€™re computing the answer for the rest of the list, then adding
    the first element to each element in the answer, and `link`ing the first element
    to the front. In principle, we can compute this solution directly, but for now
    that may be more work than finding a simpler way to answer it.)
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.8.2Â `my-running-sum`: Examples and Code[ğŸ”—](#(part._running-sum-eg-code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall how we began in [`my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29).
    Our examples [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] showed the
    following problem. When we process the rest of the list, we have forgotten everything
    about what preceded it. That is, when processing the list starting at `2` we forget
    that weâ€™ve seen a `1` earlier; when starting from `3`, we forget that weâ€™ve seen
    both `1` and `2` earlier; and so on. In other words, we keep forgetting the past.
    We need some way of avoiding that.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest thing we can do is simply change our function to carry along this
    â€œmemoryâ€, or what weâ€™ll call an accumulator. That is, imagine we were defining
    a new function, called `my-rs`. It will consume a list of numbers and produce
    a list of numbers, but in addition it will also take the sum of numbers preceding
    the current list.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should the initial sum be?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Initially there is no â€œpreceding listâ€, so we will use the additive identity:
    `0`. The type of `my-rs` is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s now re-work our examples from [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)
    as examples of `my-rs` instead. The examples use the `+` operator to append two
    lists into one (the elements of the first list followed by the elements of the
    second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, `my-rs` translates into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'All thatâ€™s then left is to call it from `my-running-sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Observe that we do not change `my-running-sum` itself to take extra arguments.
    The correctness of our code depends on the initial value of `acc` being 0\. If
    we added a parameter for `acc`, any code that calls `my-running-sum` could supply
    an unexpected value, which would distort the result. In addition, since the value
    is fixed, adding the parameter would amount to shifting additional (and needless)
    work onto others who use our code.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.8.3Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-accumulator)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recall our examples in [`my-alternating`: Examples and Code](#%28part._alternating-eg-code%29).
    There, we noticed that the code built on every-other example. We might have chosen
    our examples differently, so that from one example to the next we skipped two
    elements rather than one. Here we will see another way to think about the same
    problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the examples weâ€™ve already seen [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)].
    We wrote `my-alternating` to traverse the list essentially two elements at a time.
    Another option is to traverse it just one element at a time, but keeping track
    of whether weâ€™re at an odd or even elementâ€”<wbr>i.e., add â€œmemoryâ€ to our program.
    Since we just need to track that one piece of information, we can use a `Boolean`
    to do it. Letâ€™s define a new function for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: The extra argument accumulates whether weâ€™re at an element to keep or one to
    discard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the existing template for list functions. When we have an element,
    we have to consult the accumulator whether to keep it or not. If its value is
    `true` we `link` it to the answer; otherwise we ignore it. As we process the rest
    of the list, however, we have to remember to update the accumulator: if we kept
    an element we donâ€™t wish to keep the next one, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to determine the initial value of the accumulator. In this
    case, since we want to keep alternating elements starting with the first one,
    its initial value should be `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `my-max` using an accumulator. What does the accumulator represent? Do
    you encounter any difficulty?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.2.9Â Dealing with Multiple Answers[ğŸ”—](#(part._.Dealing_with_.Multiple_.Answers)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our discussion above has assumed there is only one answer for a given input.
    This is often true, but it also depends on how the problem is worded and how we
    choose to generate examples. We will study this in some detail now.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.1Â `uniq`: Problem Setup[ğŸ”—](#(part._uniq) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider the task of writing `uniq`:uniq is the name of a Unix utility with
    similar behavior; hence the spelling of the name. given a list of values, it produces
    a collection of the same elements while avoiding any duplicates (hence `uniq`,
    short for â€œuniqueâ€).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input: `[list: 1, 2, 1, 3, 1, 2, 4, 1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the sequence of examples this input generates? Itâ€™s really important
    you stop and try to do this by hand. As we will see there are multiple solutions,
    and itâ€™s useful for you to consider what you generate. Even if you canâ€™t generate
    a sequence, trying to do so will better prepare you for what you read next.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: How did you obtain your example? If you just â€œthought about it for a moment
    and wrote something downâ€, you may or may not have gotten something you can turn
    into a program. Programs can only proceed systematically; they canâ€™t â€œthinkâ€.
    So, hopefully you took a well-defined path to computing the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.2Â `uniq`: Examples[ğŸ”—](#(part._uniq-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It turns out there are several possible answers, because we have (intentionally)
    left the problem unspecified. Suppose there are two instances of a value in the
    list; which one do we keep, the first or the second? On the one hand, since the
    two instances must be equivalent it doesnâ€™t matter, but it does for writing concrete
    examples and deriving a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you might have generated this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: However, you might have also generated sequences that began with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: and so on. Letâ€™s work with the examples weâ€™ve worked out above.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.3Â `uniq`: Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'What is the systematic approach that gets us to this answer? When given a non-empty
    list, we split it into its first element and the rest of the list. Suppose we
    have the answer to `uniq` applied to the rest of the list. Now we can ask: is
    the first element in the rest of the list? If it is, then we can ignore it, since
    it is certain to be in the `uniq` of the rest of the list. If, however, it is
    not in the rest of the list, itâ€™s critical that we `link` it to the answer.'
  prefs: []
  type: TYPE_NORMAL
- en: This translates into the following program. For the empty list, we return the
    empty list. If the list is non-empty, we check whether the first is in the rest
    of the list. If it is not, we include it; otherwise we can ignore it for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: which weâ€™ve called `uniq-rec` instead of `uniq` to differentiate it from other
    versions of `uniq`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that weâ€™re using `.member` to check whether an element is a member of the
    list. Write a function `member` that consumes an element and a list, and tells
    us whether the element is a member of the list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Uniqueness checking has many practical applications. For example, one might
    have a list of names of people who have registered to vote in an election. To
    keep the voting fair, with only one vote allowed per person, we should remove
    duplicate names from the list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a set of examples for a function `rem-duplicate-voters` that takes a
    list of voter names and returns a list in which duplicate registrations have been
    removed. In developing your examples, consider real-world scenarios that you can
    imagine arising when identifying duplicate names. Can you identify cases in which
    two names might appear to be the same person, but not be? Cases in which two names
    might appear different but be referring to the same person?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What might you need to change about our current `uniq-rec` function to handle
    a situation like removing duplicate voters?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Responsible Computing: Context Matters When Comparing Values'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The data de-duplication context in the above exercise reminds us that different
    contexts may call for different notions of when two data values are the same.
    Sometimes, we want exact matching to determine that two strings are equal. Sometimes,
    we need methods that normalize data, either in simple ways like capitalization
    or subtler ways based on middle initials. Sometimes, we need more information
    (like street addresses in addition to names) in order to determine whether two
    items in a list should be considered â€œthe sameâ€.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is easy to write programs that encode assumptions about our data that might
    not apply in practice. This is again a situation that can be helped by thinking
    about the concrete examples on which your code needs to work in context.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.9.4Â `uniq`: Reducing Computation[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Notice that this function has a repeated expression. Instead of writing it
    twice, we could call it just once and use the result in both places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: You might think, because we replaced two function calls with one, that weâ€™ve
    reduced the amount of computation the program does. It does not! The two function
    calls are both in the two branches of the same conditional; therefore, for any
    given list element, only one or the other call to `uniq` happens. In fact, in
    both cases, there was one call to `uniq` before, and there is one now. So we have
    reduced the number of calls in the source program, but not the number that take
    place when the program runs. In that sense, the name of this section was intentionally
    misleading!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one useful reduction we can perform, which is enabled by
    the structure of `uniq-rec2`. We currently check whether `f` is a member of `r`,
    which is the list of all the remaining elements. In our example, this means that
    in the very second turn, we check whether `2` is a member of the list `[list:
    1, 3, 1, 2, 4, 1]`. This is a list of six elements, including three copies of
    `1`. We compare `2` against two copies of `1`. However, we gain nothing from the
    second comparison. Put differently, we can think of `uniq(r)` as a â€œsummaryâ€ of
    the rest of the list that is exactly as good as `r` itself for checking membership,
    with the advantage that it might be significantly shorter. This, of course, is
    exactly what `ur` represents. Therefore, we can encode this intuition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Note that all that changed is that we check for membership in `ur` rather than
    in `r`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later [[Predicting Growth](predicting-growth.html)] we will study how to formally
    study how long a program takes to run. By the measure introduced in that section,
    does the change we just made make any difference? Be careful with your answer:
    it depends on how we count â€œthe lengthâ€ of the list.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that if the list never contained duplicates in the first place, then
    it wouldnâ€™t matter which list we check membership inâ€”<wbr>but if we knew the list
    didnâ€™t contain duplicates, we wouldnâ€™t be using `uniq` in the first place! We
    will return to the issue of lists and duplicate elements in [Representing Sets
    as Lists](sets-from-lists.html).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.5Â `uniq`: Example and Code Variations[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, there are other example sequences you might have written
    down. Hereâ€™s a very different process:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the entire given list and with the empty answer (so far).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each list element, check whether itâ€™s already in the answer so far. If it
    is, ignore it, otherwise extend the answer with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are no more elements in the list, the answer so far is the answer
    for the whole list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that this solution assumes that we will be accumulating the answer as
    we traverse the list. Therefore, we canâ€™t even write the example with one parameter
    as we did before. We would argue that a natural solution asks whether we can solve
    the problem just from the structure of the data using the computation we are already
    defining, as we did above. If we cannot, then we have to resort to an accumulator.
    But because we can, the accumulator is unnecessary here and greatly complicates
    even writing down examples (give it a try!).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.6Â `uniq`: Why Produce a List?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you go back to the original statement of the `uniq` problem [[`uniq`: Problem
    Setup](#%28part._uniq%29)], youâ€™ll notice it said nothing about what order the
    output should have; in fact, it didnâ€™t even say the output needs to be a list
    (and hence have an order). In that case, we should think about whether a list
    even makes sense for this problem. In fact, if we donâ€™t care about order and donâ€™t
    want duplicates (by definition of `uniq`), then there is a much simpler solution,
    which is to produce a set. Pyret already has sets built in, and converting the
    list to a set automatically takes care of duplicates. This is of course cheating
    from the perspective of learning how to write `uniq`, but it is worth remembering
    that sometimes the right data structure to produce isnâ€™t necessarily the same
    as the one we were given. Also, later [[Representing Sets as Lists](sets-from-lists.html)],
    we will see how to build sets for ourselves (at which point, `uniq` will look
    familiar, since it is at the heart of set-ness).'
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.1Â `uniq`: Problem Setup[ğŸ”—](#(part._uniq) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider the task of writing `uniq`:uniq is the name of a Unix utility with
    similar behavior; hence the spelling of the name. given a list of values, it produces
    a collection of the same elements while avoiding any duplicates (hence `uniq`,
    short for â€œuniqueâ€).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input: `[list: 1, 2, 1, 3, 1, 2, 4, 1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the sequence of examples this input generates? Itâ€™s really important
    you stop and try to do this by hand. As we will see there are multiple solutions,
    and itâ€™s useful for you to consider what you generate. Even if you canâ€™t generate
    a sequence, trying to do so will better prepare you for what you read next.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: How did you obtain your example? If you just â€œthought about it for a moment
    and wrote something downâ€, you may or may not have gotten something you can turn
    into a program. Programs can only proceed systematically; they canâ€™t â€œthinkâ€.
    So, hopefully you took a well-defined path to computing the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.2Â `uniq`: Examples[ğŸ”—](#(part._uniq-eg) "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It turns out there are several possible answers, because we have (intentionally)
    left the problem unspecified. Suppose there are two instances of a value in the
    list; which one do we keep, the first or the second? On the one hand, since the
    two instances must be equivalent it doesnâ€™t matter, but it does for writing concrete
    examples and deriving a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you might have generated this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: However, you might have also generated sequences that began with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: and so on. Letâ€™s work with the examples weâ€™ve worked out above.
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.3Â `uniq`: Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'What is the systematic approach that gets us to this answer? When given a non-empty
    list, we split it into its first element and the rest of the list. Suppose we
    have the answer to `uniq` applied to the rest of the list. Now we can ask: is
    the first element in the rest of the list? If it is, then we can ignore it, since
    it is certain to be in the `uniq` of the rest of the list. If, however, it is
    not in the rest of the list, itâ€™s critical that we `link` it to the answer.'
  prefs: []
  type: TYPE_NORMAL
- en: This translates into the following program. For the empty list, we return the
    empty list. If the list is non-empty, we check whether the first is in the rest
    of the list. If it is not, we include it; otherwise we can ignore it for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: which weâ€™ve called `uniq-rec` instead of `uniq` to differentiate it from other
    versions of `uniq`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that weâ€™re using `.member` to check whether an element is a member of the
    list. Write a function `member` that consumes an element and a list, and tells
    us whether the element is a member of the list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Uniqueness checking has many practical applications. For example, one might
    have a list of names of people who have registered to vote in an election. To
    keep the voting fair, with only one vote allowed per person, we should remove
    duplicate names from the list.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a set of examples for a function `rem-duplicate-voters` that takes a
    list of voter names and returns a list in which duplicate registrations have been
    removed. In developing your examples, consider real-world scenarios that you can
    imagine arising when identifying duplicate names. Can you identify cases in which
    two names might appear to be the same person, but not be? Cases in which two names
    might appear different but be referring to the same person?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What might you need to change about our current `uniq-rec` function to handle
    a situation like removing duplicate voters?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Responsible Computing: Context Matters When Comparing Values'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The data de-duplication context in the above exercise reminds us that different
    contexts may call for different notions of when two data values are the same.
    Sometimes, we want exact matching to determine that two strings are equal. Sometimes,
    we need methods that normalize data, either in simple ways like capitalization
    or subtler ways based on middle initials. Sometimes, we need more information
    (like street addresses in addition to names) in order to determine whether two
    items in a list should be considered â€œthe sameâ€.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is easy to write programs that encode assumptions about our data that might
    not apply in practice. This is again a situation that can be helped by thinking
    about the concrete examples on which your code needs to work in context.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.2.9.4Â `uniq`: Reducing Computation[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Notice that this function has a repeated expression. Instead of writing it
    twice, we could call it just once and use the result in both places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: You might think, because we replaced two function calls with one, that weâ€™ve
    reduced the amount of computation the program does. It does not! The two function
    calls are both in the two branches of the same conditional; therefore, for any
    given list element, only one or the other call to `uniq` happens. In fact, in
    both cases, there was one call to `uniq` before, and there is one now. So we have
    reduced the number of calls in the source program, but not the number that take
    place when the program runs. In that sense, the name of this section was intentionally
    misleading!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one useful reduction we can perform, which is enabled by
    the structure of `uniq-rec2`. We currently check whether `f` is a member of `r`,
    which is the list of all the remaining elements. In our example, this means that
    in the very second turn, we check whether `2` is a member of the list `[list:
    1, 3, 1, 2, 4, 1]`. This is a list of six elements, including three copies of
    `1`. We compare `2` against two copies of `1`. However, we gain nothing from the
    second comparison. Put differently, we can think of `uniq(r)` as a â€œsummaryâ€ of
    the rest of the list that is exactly as good as `r` itself for checking membership,
    with the advantage that it might be significantly shorter. This, of course, is
    exactly what `ur` represents. Therefore, we can encode this intuition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Note that all that changed is that we check for membership in `ur` rather than
    in `r`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later [[Predicting Growth](predicting-growth.html)] we will study how to formally
    study how long a program takes to run. By the measure introduced in that section,
    does the change we just made make any difference? Be careful with your answer:
    it depends on how we count â€œthe lengthâ€ of the list.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that if the list never contained duplicates in the first place, then
    it wouldnâ€™t matter which list we check membership inâ€”<wbr>but if we knew the list
    didnâ€™t contain duplicates, we wouldnâ€™t be using `uniq` in the first place! We
    will return to the issue of lists and duplicate elements in [Representing Sets
    as Lists](sets-from-lists.html).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.5Â `uniq`: Example and Code Variations[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, there are other example sequences you might have written
    down. Hereâ€™s a very different process:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the entire given list and with the empty answer (so far).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each list element, check whether itâ€™s already in the answer so far. If it
    is, ignore it, otherwise extend the answer with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are no more elements in the list, the answer so far is the answer
    for the whole list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that this solution assumes that we will be accumulating the answer as
    we traverse the list. Therefore, we canâ€™t even write the example with one parameter
    as we did before. We would argue that a natural solution asks whether we can solve
    the problem just from the structure of the data using the computation we are already
    defining, as we did above. If we cannot, then we have to resort to an accumulator.
    But because we can, the accumulator is unnecessary here and greatly complicates
    even writing down examples (give it a try!).
  prefs: []
  type: TYPE_NORMAL
- en: '5.2.9.6Â `uniq`: Why Produce a List?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "Link to here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you go back to the original statement of the `uniq` problem [[`uniq`: Problem
    Setup](#%28part._uniq%29)], youâ€™ll notice it said nothing about what order the
    output should have; in fact, it didnâ€™t even say the output needs to be a list
    (and hence have an order). In that case, we should think about whether a list
    even makes sense for this problem. In fact, if we donâ€™t care about order and donâ€™t
    want duplicates (by definition of `uniq`), then there is a much simpler solution,
    which is to produce a set. Pyret already has sets built in, and converting the
    list to a set automatically takes care of duplicates. This is of course cheating
    from the perspective of learning how to write `uniq`, but it is worth remembering
    that sometimes the right data structure to produce isnâ€™t necessarily the same
    as the one we were given. Also, later [[Representing Sets as Lists](sets-from-lists.html)],
    we will see how to build sets for ourselves (at which point, `uniq` will look
    familiar, since it is at the heart of set-ness).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.10Â Monomorphic Lists and Polymorphic Types[ğŸ”—](#(part._polymorphic-data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier we wrote contracts like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'These are unsatisfying for several reasons. Consider `my-max`. The contract
    suggests that any kind of element can be in the input list, but in fact that isnâ€™t
    true: the input `[list: 1, "two", 3]` is not valid, because we canâ€™t compare `1`
    with `"two"` or `"two"` with `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we run `1 > "two"` or `"two" > 3`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rather, what we mean is a list where all the elements are of the same kind,Technically,
    elements that are also comparable. and the contract has not captured that. Furthermore,
    we donâ€™t mean that `my-max` might return any old type: if we supply it with a
    list of numbers, we will not get a string as the maximum element! Rather, it will
    only return the kind of element that is in the provided list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we mean that all elements of the list are of the same type, but they
    can be of any type. We call the former monomorphic: â€œmonoâ€ meaning one, and â€œmorphicâ€
    meaning shape, i.e., all values have one type. But the function `my-max` itself
    can operate over many of these kinds of lists, so we call it polymorphic (â€œpolyâ€
    meaning many).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we need a better way of writing these contracts. Essentially, we
    want to say that there is a type variable (as opposed to regular program variable)
    that represents the type of element in the list. Given that type, `my-max` will
    return an element of that type. We write this syntactically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: The notation `<T>` says that `T` is a type variable parameter that will be used
    in the rest of the function (both the header and the body).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this notation, we can also revisit `my-len`. Its header now becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `my-len` did not actually â€œcareâ€ that whether all the values were
    of the same type or not: it never looks at the individual elements, much less
    at pairs of them. However, as a convention we demand that lists always be monomorphic.
    This is important because it enables us to process the elements of the list uniformly:
    if we know how to process elements of type `T`, then we will know how to process
    a `List<T>`. If the list elements can be of truly any old type, we canâ€™t know
    how to process its elements.'
  prefs: []
  type: TYPE_NORMAL
